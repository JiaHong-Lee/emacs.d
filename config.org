#+TITLE:  Zacque's Literate Emacs Config
#+AUTHOR: Lee Jia Hong
#+EMAIL:  jia_hong@live.com.my
#+DATE:   [2018-06-09 Sat]
#+TAGS:   literate emacs config dotfile noexport

* Introduction

This is an attempt to put my Emacs config into an org file. By doing so, my init.el file will contains only two lines of code:

#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/init.el :results none
;;; init.el --- Where all the magic begins. -*- lexical-binding: t -*-

;;; COMMENTARY:
;;----------------------------------------------------------------------------
;;    ___ _ __ ___   __ _  ___ ___
;;   / _ \ '_ ` _ \ / _` |/ __/ __|
;;  |  __/ | | | | | (_| | (__\__ \
;; (_)___|_| |_| |_|\__,_|\___|___/
;;
;;  Citations
;;
;;     "Show me your ~/.emacs and I will tell you who you are."
;;                                                         [Bogdan Maryniuk]
;;
;;     "Emacs is like a laser guided missile. It only has to be slightly
;;      mis-configured to ruin your whole day."
;;                                                            [Sean McGrath]
;;
;;     "While any text editor can save your files, only Emacs can save your
;;      soul."
;;                                                          [Per Abrahamsen]
;;
;; Source: http://www.mygooglest.com/fni/dot-emacs.html
;;----------------------------------------------------------------------------

;;----------------------------------------------------------------------------
;;
;;                __   _,--="=--,_   __
;;               /  \."    .-.    "./  \
;;              /  ,/  _   : :   _  \/` \
;;              \  `| /o\  :_:  /o\ |\__/
;;               `-'| :="~` _ `~"=: |
;;                  \`     (_)     `/
;;           .-"-.   \      |      /   .-"-.
;;      .---{     }--|  /,.-'-.,\  |--{     }---.
;;       )  (_)_)_)  \_/`~-===-~`\_/  (_(_(_)  (
;;      (                                       )
;;       )          Recreating Purcell         (
;;      (            Emacs Experience           )
;;       )                                     (
;;      '---------------------------------------'
;;
;;----------------------------------------------------------------------------

;;; CODE:
;; SOURCE: https://github.com/jamiecollinson/dotfiles/blob/master/.emacs
(org-babel-load-file (concat user-emacs-directory "config.org"))

(provide 'init)
;; Local Variables:
;; coding: utf-8
;; no-byte-compile: t
;; End:

;;; init.el ends here
#+END_SRC

The rest is in the config.org file.

* Header

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t; -*-
#+END_SRC

* GC Tweaks

Emacs GC optimisation.

[Disabled] Knowing when the GC is running. 
[Reason] It's annoying to keep seeing the message popping up.
#+BEGIN_SRC emacs-lisp :tangle no
(setq garbage-collection-messages t)
#+END_SRC

Set GC threshold to 1GB.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold #x40000000)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defmacro k-time (&rest body)
  "Measure and return the time it takes evaluating BODY."
  `(let ((time (current-time)))
     ,@body
     (float-time (time-since time))))

;; When idle for 15sec run the GC no matter what.
(defvar k-gc-timer
  (run-with-idle-timer 15 t (lambda () (garbage-collect))))
#+END_SRC

References:
1. http://akrl.sdf.org/
   Emacs garbage collection magic hack
2. https://www.reddit.com/r/emacs/comments/cbyza2/emacs_slight_lag_allocate_more_ram_garbage/
   Where I found out about the "magic hack".

* Manage Packages and Sources
** Add Package Source

Add melpa as a package source.

#+BEGIN_SRC emacs-lisp
(require 'package)
;; (package-initialize)

(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

Load .el if newer than corresponding .elc.
#+BEGIN_SRC emacs-lisp
(setq load-prefer-newer t)
#+END_SRC

Auto download package info asynchronously on Emacs startup.
#+BEGIN_SRC emacs-lisp
(package-refresh-contents t)
#+END_SRC

Add third-party library from the ./lisp directory. This is especially useful if I clone the library from Github and work on it. Since all .el files reside in one level deep in lisp directory, I will need to add all the subdirectory to the load path.
#+BEGIN_SRC emacs-lisp
;; A helper function
;; Source: https://stackoverflow.com/a/17165074
(defun jh/directory-files (directory &optional full match nosort)
  "Retrieve the list of files and sub-directory in the DIRECTORY. Does not recurse into sub-directories. Like `directory-files' or ls command, but excluding \".\" and \"..\"."
  (let* ((files (directory-files directory full match nosort))
         (result files))
    (if full
        (progn
          (setq result (delete (concat directory "/.") result))
          (setq result (delete (concat directory "/..") result))
          result)
      (delete "." (delete ".." result)))))
#+END_SRC

With the helper function, =(jh/directory-files ~/.emacs.d/lisp)= should return a result containing all the directory in lisp as a list. With this, I will only need to loop through the list and add each subdirectory path to the =load-path=.

#+BEGIN_SRC emacs-lisp
(dolist (subdir (jh/directory-files "~/.emacs.d/lisp"))
  (add-to-list 'load-path (expand-file-name (concat "lisp/" subdir) user-emacs-directory)))
#+END_SRC

** ELPA Public Key

#+BEGIN_SRC emacs-lisp
;; Set GPG Directory for ELPA Public Key
(setq package-gnupghome-dir "~/.gnupg")
#+END_SRC

** Require-package
  
A code orginally taken from Purcell, but now modified to suit my need.
#+BEGIN_SRC emacs-lisp
(defun require-package (package)
  "Require a PACKAGE. Install PACKAGE if not already installed. PACKAGE will be required immediately after installation."
  (if (package-installed-p package)
      (require package)
    (unless package-archive-contents
      (package-refresh-contents))
    (package-install package)
    (require package)))
#+END_SRC

** External Program Dependencies

As my Emacs is tightly integrated with my OS (Arch Linux/Ubuntu), there are libraries that will not work if the executable is not found.

Check if an executable is installed.
#+BEGIN_SRC emacs-lisp
(defun check-executable-is-installed (exe &optional msg)
  "Check if an executable is installed."
  (unless (executable-find exe)
    (message (concat "'" exe "' not found. " msg))))
#+END_SRC

[TODO] If the executable is not installed, install them at Emacs boot up.
#+BEGIN_SRC emacs-lisp :tangle no

#+END_SRC

** list-packages

Open list-packages in fullframe.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'fullframe
 (fullframe list-packages quit-window))
#+END_SRC

* Utility Third Library

** Fullframe

Display some windows into "full-screen" mode.
#+BEGIN_SRC emacs-lisp
(require-package 'fullframe)
#+END_SRC

** Page-Break_lines

Display ugly ^L page breaks as tidy horizontal lines.
#+BEGIN_SRC emacs-lisp
(require-package 'page-break-lines)
(global-page-break-lines-mode)

(with-eval-after-load 'diminish ;; diminish library is loaded after this line
  (diminish 'page-break-lines-mode))
#+END_SRC

** List-unicode-display

Provides a command which searches for unicode characters by name, and displays a list of matching characters with their names in a buffer.
#+BEGIN_SRC emacs-lisp
(require-package 'list-unicode-display)
#+END_SRC

** Diminish

A useful tool to hide/redefine mode indicator at the mode line.
#+BEGIN_SRC emacs-lisp
(require-package 'diminish)
#+END_SRC

** Wgrep

#+BEGIN_SRC emacs-lisp
(require-package 'wgrep)
#+END_SRC

** Ripgrep

rg is an Emacs interface to =ripgrep=. This package interoperates well with =wgrep=. Similar: =deadgrep=.
#+BEGIN_SRC emacs-lisp
(require-package 'rg)
(with-eval-after-load 'evil
  (evil-set-initial-state 'rg-mode 'emacs))
#+END_SRC

#+NAME: Ripgrep Package
#+BEGIN_SRC emacs-lisp
(require-package 'ripgrep) ;; for integration with projectile.
(with-eval-after-load 'evil
  (evil-set-initial-state 'ripgrep-search-mode 'emacs))
#+END_SRC

Use -i for case insensitive.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'counsel
  (setq counsel-rg-base-command "rg -i --no-heading --line-number --color never %s"))
#+END_SRC

References:
1. https://oremacs.com/2018/03/05/grep-exclude/
   For counsel-rg-base-command idea.
2. https://github.com/dajva/rg.el

** Undo-Tree

Advanced undo and redo with =undo-tree=.
#+BEGIN_SRC emacs-lisp
(require-package 'undo-tree)
(diminish 'undo-tree-mode)

;; turn on everywhere
(global-undo-tree-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (evil-set-initial-state 'undo-tree-visualizer-mode 'emacs))
#+END_SRC

** Restart-Emacs
A handy tool to restart emacs, especially when using EXWM.
#+BEGIN_SRC emacs-lisp
(require-package 'restart-emacs)
#+END_SRC

** Mode-Line-Bell

A useful tool to alert from the mode-line.
#+BEGIN_SRC emacs-lisp
(require-package 'mode-line-bell)
#+END_SRC

** Hydra

#+BEGIN_SRC emacs-lisp
(require-package 'hydra)
#+END_SRC

* Keeping Secrets in Emacs with GnuPG and Auth Sources

Emacs offers to save my passwords when I want to use TRAMP. However, I would like to save it in an encrypted file. Create the file =~/.authinfo.gpg= and give only the current user permission to read-write to it.
#+BEGIN_SRC shell
chmod 600 ~/.emacs.d/.authinfo.gpg
#+END_SRC

Set it to use =gpg= explicitly (it is the default). In some case, I might want to use =gpg2=.
#+BEGIN_SRC emacs-lisp
(setq epg-gpg-program "gpg2")
#+END_SRC

Save my credential inside this self-defined file in .emacs.d dir.
#+BEGIN_SRC emacs-lisp
(setq auth-sources '((:source "~/.emacs.d/.authinfo.gpg")))
#+END_SRC

gpg2 runs the pinentry app for password prompt. Use Emacs for the prompt. 
#+BEGIN_SRC emacs-lisp
(setq epg-pinentry-mode 'loopback)
#+END_SRC

Echo a lot of additional, helpful information to the *Messages* buffer.
#+BEGIN_SRC emacs-lisp
(setq auth-source-debug t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (evil-set-initial-state 'epa-key-mode 'emacs)
  (evil-set-initial-state 'epa-key-list-mode 'emacs))
#+END_SRC

Managing secrets in Emacs. =password-store= exposes API that can be used to fetch secrets from my local .password-store.
#+BEGIN_SRC emacs-lisp
(require-package 'password-store)
#+END_SRC

References:
1. https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources
2. https://emacs.stackexchange.com/a/32554
   epg-pinentry-mode

* Personal Info

** Name and Email

Add my personal info.
#+BEGIN_SRC emacs-lisp
(setq user-full-name (password-store-get-field "personal-info" "fullname"))
(setq user-mail-address (password-store-get-field "personal-info" "personal-hotmail"))
#+END_SRC

** Emacs-memento-mori

A reminder of mortality. Deep dive into the reflection of life.

#+BEGIN_SRC emacs-lisp
(require-package 'memento-mori)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq memento-mori-birth-date (password-store-get-field "personal-info" "birthday"))
(memento-mori-mode)
#+END_SRC

References:
1. http://manuel-uberti.github.io//emacs/2019/07/06/memento-mori/
   Where I read about it.

** Sync directory

I used to using Dropbox for syncing. But after I realise that Dropbox limits Free User account to syncing three accounts, I decided to switch to Nextcloud. Here I define the directory for syncing.
#+BEGIN_SRC emacs-lisp
(defconst jh/sync-directory "/home/zacque/Dropbox/DropSyncFiles")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/file-in-sync-directory (&rest SEQUENCES)
  "Return full path to FILE in the sync-directory as defined by jh/sync-directory. Extra arguments are concatenated to the path. E.g. (jh/file-in-sync-directory SUB-DIR \"file.org\") returns path to jh/sync-directory+SUB-DIR+file.org."
  (mapconcat 'identity (push jh/sync-directory SEQUENCES) "/"))
#+END_SRC

* Personalise & Aesthetic

#+BEGIN_SRC emacs-lisp
;; UI Settings
(setq inhibit-startup-screen t)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(add-hook 'after-init-hook 'mode-line-bell-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-visual-line-mode 1) ;; wrap line
(with-eval-after-load 'diminish  ;; diminish library is loaded after this line
  (diminish 'visual-line-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Make sure C-v and M-v returns cursor to the same position.

#+BEGIN_SRC emacs-lisp
(setq scroll-preserve-screen-position 'always)
#+END_SRC

** Setup my Emacs.d Structure

Configure my directory location.

#+BEGIN_SRC emacs-lisp
(defconst jh/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))
(defun jh/emacs-subdirectory (d) (expand-file-name d jh/emacs-directory))
#+END_SRC

Create directory if not already created. Got the code from [[https://github.com/howardabrams/dot-files/blob/master/emacs.org#directory-structure][here]].

#+BEGIN_SRC emacs-lisp
(let* ((subdirs '("lisp" "backups" "themes"))
       (fulldirs (mapcar (lambda (d) (jh/emacs-subdirectory d)) subdirs)))
  (dolist (dir fulldirs)
    (when (not (file-exists-p dir))
      (message "Make directory: %s" dir)
      (make-directory dir))))
#+END_SRC

*** Move the Custom Variables into a Dedicated File

To prevent custom variable form cluttering the init.el file.
#+BEGIN_SRC emacs-lisp
(defconst custom-file "~/.emacs.d/custom.el")
(unless (file-exists-p custom-file)
  (shell-command (concat "touch " custom-file)))
(setq custom-file custom-file)
(load custom-file)
#+END_SRC

*** Define the Backup Directory
  
#+BEGIN_SRC emacs-lisp
;; Sensible Backups
(setq backup-directory-alist '(("." . "~/.emacs.d/backups"))
      backup-by-copying t       ; Don't delink hardlinks
      version-control t         ; Use version numbers on backups
      delete-old-versions t     ; Automatically delete excess backups
      kept-new-versions 20      ; Number of newest versions to keep
      kept-old-versions 5       ; Number of the old versions to keep
      vc-make-backup-files t)   ; Make backups file even from a version controlled dir
#+END_SRC

** All-the-icons

#+BEGIN_SRC emacs-lisp
(require-package 'all-the-icons)
#+END_SRC

Remember to run (all-the-icons-install-fonts) to install the Resource Fonts. Bear in mind, this will run =fc-cache -f -v= which can take some time to complete.

References:
1. github:domtronn/all-the-iocns.el

** Emacs Dashboard as Startup Screen

Use dashboard package as my startup page.
#+BEGIN_SRC emacs-lisp
(require 'dashboard)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(dashboard-setup-startup-hook)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/goto-dashboard-buffer ()
  "Switch to *dashboard* buffer. Create one if the buffer does not exist."
  (interactive)
  (get-buffer-create "*dashboard*")
  (set-buffer "*dashboard*")
  (dashboard-refresh-buffer))

(setq initial-buffer-choice 'jh/goto-dashboard-buffer)
#+END_SRC

Disable package loading init time. I don't find it useful.
#+BEGIN_SRC emacs-lisp
(setq dashboard-set-init-info nil)
#+END_SRC

Replace the ugly Emacs logo with Z(acque) logo.
#+BEGIN_SRC emacs-lisp
(setq dashboard-startup-banner
      (jh/emacs-subdirectory "images/startup_logo/small_yellow_z.png"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq dashboard-banner-logo-title
      (concat "Happy hacking, " (upcase-initials user-login-name) " - Emacs ♥ you!"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq dashboard-set-file-icons t)
(setq dashboard-set-heading-icons nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq dashboard-center-content t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq dashboard-footer "\"Look, Simba. Everything the light touches is our Kingdom.\"")
(setq dashboard-footer-icon "")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq dashboard-set-navigator t)

(setq dashboard-navigator-buttons
      `(((,(all-the-icons-octicon "globe" :height 0.8 :v-adjust 0.1)
          "Homepage" "Browse homepage"
          (lambda (&rest _) (browse-url "https://ddg.gg")))

         (,(all-the-icons-material "search")
          "Search" "Search DuckDuckGo"
          (lambda (&rest _) (counsel-search)))

         (,(all-the-icons-faicon "play" :height 0.8 :v-adjust 0.1)
          "YouTube" "Browse YouTube homepage"
          (lambda (&rest _) (browse-url "https://youtube.com")))

         (,(all-the-icons-faicon "rss" :v-adjust -0.1)
          "Feed" "Browse RSS feeds"
          (lambda (&rest _) (elfeed))))))
#+END_SRC

Use key bindings that makes sense to me.
#+BEGIN_SRC emacs-lisp
(define-key dashboard-mode-map (kbd "j") #'widget-forward)
(define-key dashboard-mode-map (kbd "n") #'widget-forward)
(define-key dashboard-mode-map (kbd "k") #'widget-backward)
(define-key dashboard-mode-map (kbd "p") #'widget-backward)
(define-key dashboard-mode-map (kbd "<tab>") #'dashboard-next-section)
(define-key dashboard-mode-map (kbd "TAB") #'dashboard-next-section)
(define-key dashboard-mode-map (kbd "<backtab>") #'dashboard-previous-section)
(define-key dashboard-mode-map (kbd "S-TAB") #'dashboard-previous-section)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (evil-set-initial-state 'dashboard-mode 'emacs))
#+END_SRC

References:
1. https://github.com/emacs-dashboard/emacs-dashboard

** UTF-8 Everywhere

Setup to have UTF-8 everywhere? To display Chinese fonts in TTY.

#+BEGIN_SRC emacs-lisp
(defun sanityinc/utf8-locale-p (v)
  "Return whether locale string V relates to a UTF-8 locale."
  (and v (string-match "UTF-8" v)))

(defun sanityinc/locale-is-utf8-p ()
  "Return t iff the \"locale\" command or environment variables prefer UTF-8."
  (or (sanityinc/utf8-locale-p (and (executable-find "locale") (shell-command-to-string "locale")))
      (sanityinc/utf8-locale-p (getenv "LC_ALL"))
      (sanityinc/utf8-locale-p (getenv "LC_CTYPE"))
      (sanityinc/utf8-locale-p (getenv "LANG"))))

(when (or window-system (sanityinc/locale-is-utf8-p))
  (set-language-environment 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-selection-coding-system (if (eq system-type 'windows-nt) 'utf-16-le 'utf-8))
  (prefer-coding-system 'utf-8))
#+END_SRC

Reference: https://github.com/hick/emacs-chinese
#+BEGIN_SRC emacs-lisp
(set-buffer-file-coding-system 'utf-8-unix)
(set-clipboard-coding-system 'utf-8-unix)
(set-file-name-coding-system 'utf-8-unix)
(set-keyboard-coding-system 'utf-8-unix)
(set-next-selection-coding-system 'utf-8-unix)
#+END_SRC
** Better buffer name conflict resolution

=uniquify= package provides a better way to resolve buffer name conflicts to the default way. Yet defer its loading since I won't often open files with identical names.

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'reverse)
(setq uniquify-separator " • ")
(setq uniquify-after-kill-buffer-p t)
(setq uniquify-ignore-buffers-re "^\\*")
#+END_SRC

** Emacs Theme

#+BEGIN_SRC emacs-lisp
(load-theme 'leuven t)
#+END_SRC

Dark mode.
#+BEGIN_SRC emacs-lisp :tangle no
(load-theme 'manoj-dark t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path (expand-file-name (concat jh/emacs-directory "themes")))
#+END_SRC

Beautiful Emacs themes:
1. https://github.com/mauforonda/emacs/blob/master/personal-theme.org

** Default Font

Express a font name using a Fontconfig pattern [fn:27]:
#+BEGIN_QUOTE
fontname[-fontsize][:name1=value1][:name2=value2]...
#+END_QUOTE
where nameN can be one of 'slant', 'weight', 'style', width', and 'spacing.

Override the default font in Emacs to using Overpass Mono developed by Redhat [fn:26].
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(font . "Overpass Mono"))
#+END_SRC

I feel like wanting a different font for coding. Reference: https://www.emacswiki.org/emacs/FacesPerBuffer.
#+BEGIN_SRC emacs-lisp
(defun jh/toggle-coding-face-mode ()
  "Sets a fixed width (monospace) font in current buffer"
  (interactive)
  (buffer-face-set '(:family "IBM Plex Mono")))

(add-hook 'prog-mode-hook 'jh/toggle-coding-face-mode)
#+END_SRC

I feel like wanting another font for reading. 
#+BEGIN_SRC emacs-lisp
(defun jh/toggle-reading-face-mode ()
  "Sets a distinct font for plain reading mode, e.g. Info."
  (interactive)
  (buffer-face-set '(:family "Montserrat")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'diminish
  (with-eval-after-load 'face-remap
    (diminish 'buffer-face-mode)))
#+END_SRC

** Display Relative Line Numbers

Display relative line numbers. Reference: https://www.reddit.com/r/emacs/comments/99e49n/displaylinenumbersmode_relative_line_numbers/e4n0271
#+BEGIN_SRC emacs-lisp
(defun jh/display-visual-line-numbers ()
  "Display visual line numbers relatively."
  (interactive)
  (display-line-numbers-mode 1)
  (setq display-line-numbers 'visual
        display-line-numbers-current-absolute t
        display-line-numbers-width 4
        display-line-numbers-widen t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook #'jh/display-visual-line-numbers)
(add-hook 'prog-mode-hook #'jh/display-visual-line-numbers)
#+END_SRC

Prettify line-number faces. Reference: https://www.reddit.com/r/emacs/comments/6noyxa/customizing_the_new_native_line_numbers_in_emacs
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'line-number nil
                    :font "Hack"
                    :height 80)

(set-face-attribute 'line-number-current-line nil
                    :font "Hack"
                    :height 80
                    :background "#ffdfaa"
                    :foreground "#3a3a3a")
#+END_SRC

Define a function to make it easy to disable page number display inside a mode. It is used in pdf-view-mode.
#+BEGIN_SRC emacs-lisp
(defun display-line-numbers-disable-hook ()
  "Disable display-line-numbers locally."
  (display-line-numbers-mode -1))
#+END_SRC

** Initial Scratch Message

Taken from Purcell.
#+BEGIN_SRC emacs-lisp
(setq-default initial-scratch-message
              (concat ";; Happy hacking, " user-login-name " - Emacs ♥ you!\n\n"))
#+END_SRC

** Prettify Symbol

Combine two characters into one composed character. Taken from Purcell. 
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'global-prettify-symbols-mode)
#+END_SRC

** 80% Width

Center align content for better reading experience. Set-face-attribute is needed to remove the grey background colour.
#+BEGIN_SRC emacs-lisp
(defun jh/centre-align-buffer-content ()
  "Set the fringe to center align content to 80% width as in CSS."
  (interactive)
  (let ((full-width (window-width))
        (target-width (* .60 (window-width))))
    (set-fringe-style (round (- full-width target-width)))
    (set-face-attribute 'fringe nil :background nil)))
#+END_SRC

** Calendar Settings

Use the format year/month/day.
#+BEGIN_SRC emacs-lisp
(setq calendar-date-style 'iso)
#+END_SRC

* Editing Utilities

This is where I put codes that help with editing in general, no matter what the language be.

** Trailing Whitespace
Source: Purcell's init-whitespace.el

#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/show-trailing-whitespace ()
  "Enable display of trailing whitespace in this buffer."
  (setq-local show-trailing-whitespace t))

(dolist (hook '(prog-mode-hook text-mode-hook conf-mode-hook))
  (add-hook hook 'jh/show-trailing-whitespace))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require-package 'whitespace-cleanup-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'global-whitespace-cleanup-mode)
(diminish 'whitespace-cleanup-mode)
#+END_SRC

** Guide Key

Show key-binding completion suggestions or ey-binding hints.
#+BEGIN_SRC emacs-lisp
(require-package 'guide-key)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq guide-key/guide-key-sequence t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'guide-key-mode)
(diminish 'guide-key-mode)
#+END_SRC

** Multiple-cursors

#+BEGIN_SRC emacs-lisp
(require-package 'multiple-cursors)
#+END_SRC

** Symbol-overlay

A rewrite of ~highlight-symbol~. It highlights all the variables usages in a file.
#+BEGIN_SRC emacs-lisp
(require-package 'symbol-overlay)
(diminish 'symbol-overlay-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(dolist (hook '(prog-mode-hook html-mode-hook yaml-mode-hook conf-mode-hook))
    (add-hook hook 'symbol-overlay-mode))
#+END_SRC

** No Tabs

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 4)
#+END_SRC

References:
1. https://www.emacswiki.org/emacs/NoTabs

** Auto-Revert

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'autorevert
  (diminish 'auto-revert-mode))
#+END_SRC

** Aggressive Indentation

Found this package from Purcell's config.
#+BEGIN_SRC emacs-lisp
(require-package 'aggressive-indent)
(diminish 'aggressive-indent-mode)
#+END_SRC

* Enable Ivy Mode

#+BEGIN_SRC emacs-lisp
(require-package 'smex) ;; to power ivy

(require-package 'ivy)
(ivy-mode 1)
(diminish 'ivy-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq ivy-use-virtual-buffers t) ;; includes recentf and bookmarks
(setq enable-recursive-minibuffers t)
(setq ivy-virtual-abbreviate 'fullpath)
(setq ivy-count-format "")
#+END_SRC

Remove =counsel-M-x= initial-inputs "^" character [fn:19].
#+BEGIN_SRC emacs-lisp
(setq-default ivy-initial-inputs-alist '((man . "^")
                                         (woman . "^")))
#+END_SRC

IDO-style directory navigation [fn:13]. 
#+BEGIN_SRC emacs-lisp
(define-key ivy-minibuffer-map (kbd "RET") #'ivy-alt-done)
(dolist (key '("C-j" "C-RET"))
  (define-key ivy-minibuffer-map (kbd key) #'ivy-immediate-done))
#+END_SRC

Power up Ivy with Counsel mode.
#+BEGIN_SRC emacs-lisp
(require-package 'counsel)
(diminish 'counsel-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-x") 'counsel-M-x) ;; Couple with smex mode!
(global-set-key (kbd "C-x C-f") 'counsel-find-file)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun sanityinc/enable-ivy-flx-matching ()
    "Make `ivy' matching work more like IDO."
    (interactive)
    (require-package 'flx)
    (setq-default ivy-re-builders-alist
                  '((t . ivy--regex-fuzzy))))
#+END_SRC

Use Ivy with Historian-mode [fn:14]. Historian-mode stores the results of completing-read and similar functions persistently to provide better completion candidates for recent or frequent used item.

#+BEGIN_SRC emacs-lisp
(require-package 'historian)
(historian-mode 1)

(require-package 'ivy-historian)
(ivy-historian-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun open-file-directory-from-path (x)
  "Open the directory given a file path"
  (find-file (file-name-directory x)))

(ivy-set-actions 'ivy-switch-buffer '(("d" open-file-directory-from-path "directory")))
#+END_SRC

** Counsel-Search

Add a custom ddg search engine to use familiar ddg search result page.
#+BEGIN_SRC emacs-lisp
(add-to-list 'counsel-search-engines-alist '(ddgz "https://duckduckgo.com/ac/" "https://duckduckgo.com/?q=" counsel--search-request-data-ddg))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq counsel-search-engine 'ddgz)
#+END_SRC

* Recentf 

Settings for tracking recent files.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'recentf-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-default recentf-max-menu-items 1000
              recentf-max-saved-items nil     ;; save the entire list
              recentf-exclude '("/tmp/" "/ssh:"))
#+END_SRC

* Enable Evil mode

** Evil

#+BEGIN_SRC emacs-lisp
;; Evil mode
(require-package 'evil)
(evil-mode 1)
#+END_SRC

Override the default 'j' and 'k' key movements.

#+BEGIN_SRC emacs-lisp
(define-key evil-motion-state-map [remap evil-next-line] 'evil-next-visual-line)
(define-key evil-motion-state-map [remap evil-previous-line] 'evil-previous-visual-line)
#+END_SRC 

"C-o" is evil-jump-backward. Therefore I set "C-S-o" to jump forward.
#+BEGIN_SRC emacs-lisp
(define-key evil-motion-state-map (kbd "C-S-o") 'evil-jump-forward)
#+END_SRC

Together with the global-subword-mode, evil can detect camelcase word such as CamelCase. =dw= should only delete the word 'Camel'.

#+BEGIN_SRC emacs-lisp
(global-subword-mode)
(diminish 'subword-mode)
#+END_SRC

Set some built-in modes to launch in emacs-state.

#+BEGIN_SRC emacs-lisp
;; SET EVIL INITIAL STATE FOR SOME MODES (IN ADDITION TO THE DEFAULT)
(cl-loop for (mode . state) in
	 '((image-mode . emacs)
	   (eww-mode . emacs)
	   (Info-mode . emacs)
	   (calendar-mode . emacs)
	   (process-menu-mode . emacs)
	   (diff-mode . emacs))
	 do (evil-set-initial-state mode state))
#+END_SRC

Redefine =evil-ex-commands= to close buffers instead of the frame (Emacs windows).
#+BEGIN_SRC emacs-lisp
(evil-define-command jh/evil-save-modified-and-close-buffer (file &optional bang)
  "Saves the current buffer and closes the buffer."
  :repeat nil
  (interactive "<f><!>")
  (when (buffer-modified-p)
    (evil-write nil nil nil file bang))
  (kill-buffer))

(evil-define-command jh/evil-save-and-close-buffer (file &optional bang)
  "Saves the current buffer and closes the window."
  :repeat nil
  (interactive "<f><!>")
  (evil-write nil nil nil file bang)
  (kill-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; ZZ from normal mode kill the buffer rather than quitting emacs
(define-key evil-normal-state-map "ZZ" 'jh/evil-save-modified-and-close-buffer)

;; Ex :q should kill the current buffer rather than quitting emacs entirely
(evil-ex-define-cmd "q" 'kill-this-buffer)

;; Type :quit to close emacs
(evil-ex-define-cmd "quit" 'evil-quit)

(evil-ex-define-cmd "wq" 'jh/evil-save-and-close-buffer)
#+END_SRC

** Evil Visual Mark

Display Evil marks in the buffer.
#+BEGIN_SRC emacs-lisp
(require 'evil-visual-mark-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'evil-mode-hook 'evil-visual-mark-mode)
#+END_SRC

** Evil Search

Make evil-search similar to Vim's search. 
Issue: 
1. Highlight does not go away.
#+BEGIN_SRC emacs-lisp :tangle no
(evil-select-search-module 'evil-search-module 'evil-search)
#+END_SRC

Default values. Make it explicit.
#+BEGIN_SRC emacs-lisp
(setq evil-search-wrap t
      evil-regexp-search t)
#+END_SRC

To show (current match/total matches) info in the mode-line using evil-search-forward.
#+BEGIN_SRC emacs-lisp
(require-package 'evil-anzu)
#+END_SRC

References:
1. https://github.com/syohex/emacs-anzu
2. https://stackoverflow.com/a/42371439

** Evil Smart-Jump

Use this package to go to definitions by leveraging a series of methods.
#+BEGIN_SRC emacs-lisp
(require-package 'smart-jump)
#+END_SRC

Use the ready made =smart-jumps=.
#+BEGIN_SRC emacs-lisp
(smart-jump-setup-default-registers)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal 'global [remap evil-goto-definition] 'smart-jump-go)
#+END_SRC

** Evil-Sentence

Use evil-sentence to operate on a text sentence object.

#+BEGIN_SRC emacs-lisp
;; evil-sentence
(require-package 'sentence-navigation)

;;; Using evil-sentence/sentence-navigation
(define-key evil-outer-text-objects-map "s" 'sentence-nav-evil-a-sentence)
(define-key evil-inner-text-objects-map "s" 'sentence-nav-evil-inner-sentence)
#+END_SRC

** Evil-Matchit

Use evil-matchit to jump between HTML tags using '%'.

#+BEGIN_SRC emacs-lisp
(require-package 'evil-matchit)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-evil-matchit-mode t)
#+END_SRC

** Evil-Surround

Use evil-surround to deal with surrounding quotes or tags.

#+BEGIN_SRC emacs-lisp
(require-package 'evil-surround)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-evil-surround-mode t)
#+END_SRC

Problem: evil-surround-change inserts unwanted spaces. E.g. it changes (this-form) to [ this-form ]. This code solves that. Reference: https://github.com/emacs-evil/evil-surround/issues/86#issuecomment-258552759
#+BEGIN_SRC emacs-lisp
;; use non-spaced pairs when surrounding with an opening brace
(evil-add-to-alist
 'evil-surround-pairs-alist
 ?\( '("(" . ")")
 ?\[ '("[" . "]")
 ?\{ '("{" . "}")
 ?\) '("( " . " )")
 ?\] '("[ " . " ]")
 ?\} '("{ " . " }"))
#+END_SRC

** Evil-Numbers

#+BEGIN_SRC emacs-lisp
(require-package 'evil-numbers)
#+END_SRC

Use the keypad + and - without shadowing the regular + and -.
#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "<kp-add>") 'evil-numbers/inc-at-pt)
(define-key evil-normal-state-map (kbd "<kp-subtract>") 'evil-numbers/dec-at-pt)
#+END_SRC

References:
1. https://github.com/cofi/evil-numbers

** Evil-Exchange

#+BEGIN_SRC emacs-lisp
(require-package 'evil-exchange)
#+END_SRC

Use define-key instead of =evil-exchange-cx-install=. Wrapping it in a function makes it feels difficult and opaque.
#+BEGIN_SRC emacs-lisp
(define-key evil-operator-state-map "x" 'evil-exchange/cx)
(define-key evil-visual-state-map "X" 'evil-exchange)
#+END_SRC

References:
1. https://github.com/Dewdrops/evil-exchange
2. http://vimcasts.org/episodes/swapping-two-regions-of-text-with-exchange-vim

** Evil-Args

Funtion arguments as textobjects.
#+BEGIN_SRC emacs-lisp
(require-package 'evil-args)
#+END_SRC

Bind evil-args text objects.
#+BEGIN_SRC emacs-lisp
(define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
(define-key evil-outer-text-objects-map "a" 'evil-outer-arg)
#+END_SRC

For C-derivative modes.
#+BEGIN_SRC emacs-lisp
(defun jh/evil-args-switch-to-c-mode ()
  "Switch evil-args parameters to adapt to C-derivative modes"
  (setq evil-args-delimiters '(", " ";")))

(add-hook 'c-mode-hook #'jh/evil-args-switch-to-c-mode)
#+END_SRC

For Lispy modes, see [[evil-lisp-args][evil-lisp-args]].

** Archived

=evil-escape= is useful to define a customised key sequence to escape from insert state and everything else in Emacs, such as using =fd= to go into normal state.

* Flycheck Mode

Flycheck was once a superior alternative to Flymake. Since Emacs version 26.1, it introduces a new re-written Flymake. So the difference is now not so big. Feel free to check out the discussion here [fn:20].
#+BEGIN_SRC emacs-lisp
(require-package 'flycheck)
(global-flycheck-mode)
#+END_SRC

* Company Mode
  
Company-mode is a modular in-buffer completion framework for Emacs. Company stands for "complete anything". 
#+BEGIN_SRC emacs-lisp
(require-package 'company)
(add-hook 'after-init-hook 'global-company-mode)

(diminish 'company-mode " Ⓒ")
#+END_SRC

Use <TAB> to indent to popup company completion. By default, indent-for-tab + tab-alwasy-indent 'complete with popup default completion-at-point popup for me. This should override the default behaviour.
#+BEGIN_SRC emacs-lisp
(define-key company-mode-map [remap indent-for-tab-command]
    'company-indent-or-complete-common)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq tab-always-indent 'complete)
#+END_SRC

Force out of selection by typing non-match characters.
#+BEGIN_SRC emacs-lisp
(setq company-require-match 'never)
#+END_SRC

Disable the downcase that company does to the variables.
#+BEGIN_SRC emacs-lisp
(setq company-dabbrev-downcase nil)
#+END_SRC

[Before] Display company autocomplete immediately.
[Changes] Change to less immediate because it is too laggy?
#+BEGIN_SRC emacs-lisp
;; (setq company-idle-delay 0)
(setq company-idle-delay 0.5)
#+END_SRC

Use "C-n" or "C-p" to cycle through auto-complete candidates.
#+BEGIN_SRC emacs-lisp
(defun jh/reverse-company-complete-common-or-cycle ()
  "Same function but move in reverse direction."
  (interactive)
  (company-complete-common-or-cycle -1))

(define-key company-active-map (kbd "M-n") nil)
(define-key company-active-map (kbd "M-p") nil)
(define-key company-active-map (kbd "C-n") #'company-complete-common-or-cycle)
(define-key company-active-map (kbd "C-p") #'jh/reverse-company-complete-common-or-cycle)
(define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
(define-key company-active-map (kbd "<tab>") 'company-complete-common-or-cycle)
(define-key company-active-map (kbd "S-TAB") 'jh/reverse-company-complete-common-or-cycle)
(define-key company-active-map (kbd "<backtab>") 'reverse-company-complete-common-or-cycle)
#+END_SRC

Display function/variable documentation on selected candidates.
#+BEGIN_SRC emacs-lisp
(require-package 'company-quickhelp)
(add-hook 'after-init-hook 'company-quickhelp-mode)
#+END_SRC

References:
1. https://github.com/company-mode/company-mode
2. https://emacs.stackexchange.com/a/23937
3. https://github.com/company-mode/company-mode/wiki/Switching-from-AC
4. https://github.com/company-mode/company-mode/issues/526
   YouCompleteMe-style tab completion.
5. https://github.com/company-mode/company-mode/issues/94
   Integrate company with 'ident-for-tab-command'.

* Org-Mode

#+BEGIN_SRC emacs-lisp
(defface org-block-begin-line
  '((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
  "Face used for the line delimiting the begin of source blocks.")

(defface org-block-background
  '((t (:background "#FFFFEA")))
  "Face used for the source block background.")

(defface org-block-end-line
  '((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
  "Face used for the line delimiting the end of source blocks.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'org)
#+END_SRC

To fontify the whole heading lines of an org-src-block.
#+BEGIN_SRC emacs-lisp
(setq org-fontify-whole-heading-line t)
#+END_SRC

Open txt file in org-mode.
#+BEGIN_SRC emacs-lisp
;; Associate txt file with org-mode
(add-to-list 'auto-mode-alist '("\\.txt\\'" . org-mode))
#+END_SRC

Open an org file with hard indentation by default.
#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
#+END_SRC

=(diminish 'org-indent-mode)= does not work directly. The call to it must occur after org-indent.el has ben loaded. Reference: https://emacs.stackexchange.com/questions/22531/diminish-org-indent-mode
#+BEGIN_SRC emacs-lisp
(require 'org-indent)
(diminish 'org-indent-mode)
#+END_SRC

Prevent deleting hidden texts. https://emacs.stackexchange.com/a/2091
#+BEGIN_SRC emacs-lisp
(setq org-catch-invisible-edits 'smart-and-error)
#+END_SRC

Use =org-cliplink= to fetch a page title and format it into an org-link.
#+BEGIN_SRC emacs-lisp
(require-package 'org-cliplink)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c l") 'org-store-link)
#+END_SRC

Override Org-mode subscript and superscripts default behaviours for display. Mixing LaTeX with plain text.
#+BEGIN_SRC emacs-lisp
(setq org-use-sub-superscripts "{}")
#+END_SRC

Align all tables automatically upon opening the file. If not, I would have to C-c C-c to hide them.
#+BEGIN_SRC emacs-lisp
(setq org-startup-align-all-tables t)
#+END_SRC

Open org-file with inline images shown automatically.
#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images t)
#+END_SRC

** Personalisation

Beautifying org-mode.

=org-bullets= replaces org default '*' with UTF-8 bullets, which is customisable.
#+BEGIN_SRC emacs-lisp
(require-package 'org-bullets)
(add-hook 'org-mode-hook 'org-bullets-mode)
#+END_SRC

Use Iosevka Font for Org-mode: https://shreyas.ragavan.co/post/951004ce-add0-4e7e-b6e2-2932e0dee429/
#+BEGIN_SRC emacs-lisp
(defun jh/toggle-org-mode-writing-font ()
  "Sets a special font for Org-mode writing."
  (interactive)
  (buffer-face-set '(:family "IosevkaCC")))

(add-hook 'org-mode-hook 'jh/toggle-org-mode-writing-font)
#+END_SRC

** Org Journal

Use Org-mode for writing journals.
TODO: Auto insert new datetree under heading with unique tag journal.
#+BEGIN_SRC emacs-lisp
(defun jh/find-or-create-today-datetree (pfx)
  "Find or create today datetree entry in the current buffer. Call with prefix C-u to input DATE int the format (M D Y)."
  (interactive "p")
  (let ((cal-date))
    (if (eq pfx 1)
        (setq cal-date (calendar-current-date))
      (setq cal-date (read)))
    (org-datetree-find-date-create cal-date 'subtree-at-point)))
#+END_SRC

** Org-Tags

Reduce the distance for better viewing at half-split windows.
#+BEGIN_SRC emacs-lisp
(setq org-tags-column -40)
#+END_SRC

** PEP Org-Link

This section puts the codes about Python integration with Org-mode.

Add a new org-link type for PEP.
#+BEGIN_SRC emacs-lisp
(org-add-link-type "pep" 'org-pep-open)

(defun org-pep-open (number)
  "Visit pep NUMBER on python.org"
  (let* ((base-string "https://www.python.org/dev/peps/pep-%04d/")
         (num (string-to-number number))
         (final-url (format base-string num)))
    (browse-url final-url)))
#+END_SRC

** GitHub Org-Link

This section defines the org-link type for GitHub repo and corresponding issues. Org-link format: 
1. Repo
   github:<owner>/<repo_name>.
2. Issues
   github:<owner>/<repo_name>#XXX, where XXX is the issue number.
3. Pull requests
   github:<owner>/<repo_name>#XXX, where XXX is the issue number.

*NOTE:* GitHub issues and pull requests share the same numbering system. And "https://github.com/abc/abc/issues/NNN" will auto-resolve to "https://github.com/abc/abc/pull/NNN" if the issue is a pull request.

#+BEGIN_SRC emacs-lisp
(org-add-link-type "github" 'org-github-open)

(defun org-github-open (REPO)
  "Visit REPO at GitHub.com."
  (let* ((base-url "https://github.com/%s")
         (issue-url "/issues/%s")
         (hashpos (string-match-p "#" REPO)))
    (if hashpos
        (browse-url
         (concat (format base-url (substring REPO nil hashpos))
                 (format issue-url (substring REPO (+ hashpos 1) nil)))) ;; extract without '#'
      (browse-url (format base-url REPO)))))
#+END_SRC

* Org Sidebar

#+BEGIN_SRC emacs-lisp
(require-package 'org-sidebar)
#+END_SRC

* Org Export

Override Org-mode subscript and superscripts default behaviours during export.
#+BEGIN_SRC emacs-lisp
(setq org-export-with-sub-superscripts "{}")
#+END_SRC

* Org GTD

** Organise My Life Into Org Files

Tasks are separated into logical groupings/projects. For large groupings/projects, separate org files are used to store the tasks. Subdirectories are used for collections of files for multiple projects that belong together.

For non-work related tasks:

| Filename | Description                                |
|----------+--------------------------------------------|
| todo.txt | Personal tasks and things to keep track of |

For org capture notes and tasks:

| Filename   | Description           |
|------------+-----------------------|
| refile.txt | Captured tasks bucket |

For work-related org-files to keep business notes:

| Filename                | Description                      |
|-------------------------+----------------------------------|
| bigdata.txt             | Big Data course notes            |
| datamining.txt          | Data Mining course notes         |
| bigdata_assignment1.txt | Assignment 1 for Big Data course |

By separating tasks into files, I can add/drop org files according to my needs to keep only what is important visible in agenda views.

References:
1. http://doc.norang.ca/org-mode.html

** Definition of Projects, Subprojects, and Stuck Projects

Any task with a subtask using a todo keyword is a project. Projects are 'stuck' if they do not have a subtask with a =NEXT= todo state. Projects can have subprojects and they can also be stuck.

#+BEGIN_SRC emacs-lisp
(defun jh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (jh/find-project-task)
      (if (equal (point) task)
          nil
        t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
        (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq is-subproject t))))
    (and is-a-task is-subproject)))
#+END_SRC

References:
1. http://doc.norang.ca/org-mode.html

** Org Agenda Views

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c a") 'org-agenda)
(global-set-key (kbd "<f12>") 'org-agenda)
#+END_SRC

Show only today's view. Use the weekly view for weekly review.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-span 'day)
#+END_SRC

Override the default to begin a week on Sunday. Source: https://stackoverflow.com/a/32426234
#+BEGIN_SRC emacs-lisp
(setq org-agenda-start-on-weekday 0)
#+END_SRC

Load all the .txt files into org-agenda.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-file-regexp "\\`[^.].*\\(\\.org\\|\\.txt\\)\\'")
#+END_SRC

Assign "org" as my project directory, so that every project in the directory will be automatically added to org-agenda. This frees me from minute configuring every time I change my project working on.
#+BEGIN_SRC emacs-lisp
(defun jh/get-all-subdirs (path depth)
  "Get all subdirectories under the directory PATH"
  (split-string (shell-command-to-string (concat "find " path " -type d" " -maxdepth " depth)) "\n" t))
#+END_SRC

#+RESULTS:
: jh/get-all-subdirs

#+BEGIN_SRC emacs-lisp
;; Need a function to return all the subdirectories + the directory itself 
;; (setq org-agenda-files (jh/directory-files (jh/file-in-sync-directory "org") t "\\`[^.#].*\\(org\\|txt\\)\\'" nil))
(setq org-agenda-files (jh/get-all-subdirs (jh/file-in-sync-directory "org") "1"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(setq org-tags-match-list-sublevels 'indented)
#+END_SRC

I don't need an indicator of tasks blocked.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-dim-blocked-tasks nil)
#+END_SRC

Start showing the deadline in Org-Agenda for task going to due in 90 days.
#+BEGIN_SRC emacs-lisp
(setq org-deadline-warning-days 0)
#+END_SRC

Customise Org-agenda TODO view.
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-agenda-prefix-format
      '((agenda . " %i %-12:c%?-12t% s")
	(todo . " %i %-12:c %l")
	(tags . " %i %-12:c")
	(search . " %i %-12:c")))
#+END_SRC

References:
1. https://emacs.stackexchange.com/questions/5900/how-can-i-view-the-hierarchy-of-todo-keywords-in-org-agenda-mode
2. http://www.cachestocaches.com/2016/9/my-workflow-org-agenda/
   Emacs config: https://github.com/gjstein/emacs.d/blob/master/config/gs-org.el
3. http://doc.norang.ca/org-mode.html#CustomAgendaViews

*** Org Agenda Utility

#+BEGIN_SRC emacs-lisp
(defun jh/skip-non-archivable-tasks ()
  "Skip trees that are not available for archiving"
  (save-restriction
    (widen)
    ;; Consider only tasks with done todo headings as archivable candidates
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
          (subtree-end (save-excursion (org-end-of-subtree t))))
      (if (member (org-get-todo-state) org-todo-keywords-1)
          (if (member (org-get-todo-state) org-done-keywords)
              (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                     (a-month-ago (* 60 60 24 (+ daynr 1)))
                     (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                     (this-month (format-time-string "%Y-%m-" (current-time)))
                     (subtree-is-current (save-excursion
                                           (forward-line 1)
                                           (and (< (point) subtree-end)
                                                (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                (if subtree-is-current
                    subtree-end ; Has a date in this month or last month, skip it
                  nil))  ; available to archive
            (or subtree-end (point-max)))
        next-headline))))
#+END_SRC

#+RESULTS:
: jh/skip-non-archivable-tasks

#+BEGIN_SRC emacs-lisp
(defun jh/list-sublevels-for-projects-indented ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels 'indented)
    (setq org-tags-match-list-sublevels nil))
  nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/list-sublevels-for-projects ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels t)
    (setq org-tags-match-list-sublevels nil))
  nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar jh/hide-scheduled-and-waiting-next-tasks t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/toggle-next-task-display ()
  (interactive)
  (setq jh/hide-scheduled-and-waiting-next-tasks
        (not jh/hide-scheduled-and-waiting-next-tasks))
  (when  (equal major-mode 'org-agenda-mode)
    (org-agenda-redo))
  (message "%s WAITING and SCHEDULED NEXT Tasks"
           (if jh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-stuck-projects ()
  "Skip trees that are not stuck projects"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (jh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                nil
              next-headline)) ; a stuck project, has subtasks but no next task
        nil))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-non-stuck-projects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (jh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                next-headline
              nil)) ; a stuck project, has subtasks but no next task
        next-headline))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (if (save-excursion (jh/skip-non-stuck-projects))
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((jh/is-project-p)
            nil)
           ((and (jh/is-project-subtree-p) (not (jh/is-task-p)))
            nil)
           (t
            subtree-end))))
    (save-excursion (org-end-of-subtree t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-non-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((jh/is-task-p)
        nil)
       (t
        next-headline)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-project-trees-and-habits ()
  "Skip trees that are projects"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((jh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
        next-headline)
       ((and jh/hide-scheduled-and-waiting-next-tasks
             (member "WAITING" (org-get-tags-at)))
        next-headline)
       ((jh/is-project-p)
        next-headline)
       ((and (jh/is-task-p) (not (jh/is-project-subtree-p)))
        next-headline)
       (t
        nil)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-project-tasks-maybe ()
  "Show tasks related to the current restriction.
When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
When not restricted, skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max))))
           (limit-to-project (marker-buffer org-agenda-restrict-begin)))
      (cond
       ((jh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (not limit-to-project)
             (jh/is-project-subtree-p))
        subtree-end)
       ((and limit-to-project
             (jh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       (t
        nil)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-project-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((jh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       ((jh/is-project-subtree-p)
        subtree-end)
       (t
        nil)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-non-project-tasks ()
  "Show project tasks.
Skip project and sub-project tasks, habits, and loose non-project tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((jh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (jh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       ((not (jh/is-project-subtree-p))
        subtree-end)
       (t
        nil)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-projects-and-habits ()
  "Skip trees that are projects and tasks that are habits"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((jh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/skip-non-subprojects ()
  "Skip trees that are not projects"
  (let ((next-headline (save-excursion (outline-next-heading))))
    (if (jh/is-subproject-p)
        nil
      next-headline)))
#+END_SRC

*** Org Agenda Custom Views

#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("n" "Agenda and all TODOs"
         ((agenda #1="")
          (alltodo #1#)))
        ("w" "Weekly Review"
         ((agenda "")))
        (" " "Agenda"
         ((agenda "" nil)
          (tags "REFILE"
                ((org-agenda-overriding-header "Tasks to Refile")
                 (org-tags-match-list-sublevels nil)))
          (tags-todo "-CANCELLED/!"
                     ((org-agenda-overriding-header "Stuck Projects")
                      (org-agenda-skip-function 'jh/skip-non-stuck-projects)
                      (org-agenda-sorting-strategy '(category-keep))))
          (tags-todo "-HOLD-CANCELLED/!"
                     ((org-agenda-overriding-header "Projects")
                      (org-agenda-skip-function 'jh/skip-non-projects)
                      (org-tags-match-list-sublevels 'indented)
                      (org-agenda-sorting-strategy '(category-keep))))
          (tags-todo "-CANCELLED/!NEXT"
                     ((org-agenda-overriding-header (concat "Project Next Tasks"
                                                            (if jh/hide-scheduled-and-waiting-next-tasks
                                                                ""
                                                              " (including WAITING and SCHEDULED tasks)")))
                      (org-agenda-skip-function 'jh/skip-projects-and-habits-and-single-tasks)
                      (org-tags-match-list-sublevels t)
                      (org-agenda-todo-ignore-scheduled jh/hide-scheduled-and-waiting-next-tasks)
                      (org-agenda-todo-ignore-deadlines jh/hide-scheduled-and-waiting-next-tasks)
                      (org-agenda-todo-ignore-with-date jh/hide-scheduled-and-waiting-next-tasks)
                      (org-agenda-sorting-strategy '(todo-state-down effort-up category-keep))))
          (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                     ((org-agenda-overriding-header (concat "Project Subtasks"
                                                            (if jh/hide-scheduled-and-waiting-next-tasks
                                                                ""
                                                              " (including WAITING and SCHEDULED tasks)")))
                      (org-agenda-skip-function 'jh/skip-non-project-tasks)
                      (org-agenda-todo-ignore-scheduled jh/hide-scheduled-and-waiting-next-tasks)
                      (org-agenda-todo-ignore-deadlines jh/hide-scheduled-and-waiting-next-tasks)
                      (org-agenda-todo-ignore-with-date jh/hide-scheduled-and-waiting-next-tasks)
                      (org-agenda-sorting-strategy '(category-keep))))
          (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                     ((org-agenda-overriding-header (concat "Standalone Tasks"
                                                            (if jh/hide-scheduled-and-waiting-next-tasks
                                                                ""
                                                              " (including WAITING and SCHEDULED tasks)")))
                      (org-agenda-skip-function 'jh/skip-project-tasks)
                      (org-agenda-todo-ignore-scheduled jh/hide-scheduled-and-waiting-next-tasks)
                      (org-agenda-todo-ignore-deadlines jh/hide-scheduled-and-waiting-next-tasks)
                      (org-agenda-todo-ignore-with-date jh/hide-scheduled-and-waiting-next-tasks)
                      (org-agenda-sorting-strategy '(category-keep))))
          (tags-todo "-CANCELLED+WAITING|HOLD/!"
                     ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                            (if jh/hide-scheduled-and-waiting-next-tasks
                                                                ""
                                                              " (including WAITING and SCHEDULED tasks)")))
                      (org-agenda-skip-function 'jh/skip-non-tasks)
                      (org-tags-match-list-sublevels nil)
                      (org-agenda-todo-ignore-scheduled jh/hide-scheduled-and-waiting-next-tasks)
                      (org-agenda-todo-ignore-deadlines jh/hide-scheduled-and-waiting-next-tasks)))
          (tags "-REFILE/"
                ((org-agenda-overriding-header "Tasks to Archive")
                 (org-agenda-skip-function 'jh/skip-non-archivable-tasks)
                 (org-tags-match-list-sublevels nil))))
         nil)
        ))
#+END_SRC

** Org and Appt

#+BEGIN_SRC emacs-lisp
(require 'appt)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq appt-message-warning-time 60)
(setq appt-display-interval 10)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/org-agenda-to-appt ()
  "Erase all reminders and rebuilt reminders for today from the agenda."
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))
#+END_SRC

Build the reminder after Emacs started.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'jh/org-agenda-to-appt)
#+END_SRC

Rebuild the reminders everytime the agenda is display.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-finalize-hook 'jh/org-agenda-to-appt 'append)
#+END_SRC

Activate appointments to get notifications.
#+BEGIN_SRC emacs-lisp
(appt-activate t)
#+END_SRC

Reset the appointments if I leave Emacs running overnight.
#+BEGIN_SRC emacs-lisp
(run-at-time "24:01" nil 'jh/org-agenda-to-appt)
#+END_SRC

References:
1. http://doc.norang.ca/org-mode.html#Reminders

** Org Tasks

Bernt Hansen[fn:30] has a good article on GTD. The following diagram shows the possible state transitions for a tasks:
#+begin_src plantuml :file normal_task_states.png :cache yes
title Task States
[*] -> TODO
TODO -> NEXT
TODO -> DONE
NEXT -> DONE
DONE -> [*]
TODO --> WAITING
WAITING --> TODO
NEXT --> WAITING
WAITING --> NEXT
HOLD --> CANCELLED
WAITING --> CANCELLED
CANCELLED --> [*]
TODO --> HOLD
HOLD --> TODO
TODO --> CANCELLED
TODO: t
NEXT: n
DONE: d
WAITING:w
note right of WAITING: Note records\nwhat it is waiting for
HOLD:h
note right of CANCELLED: Note records\nwhy it was cancelled
CANCELLED:c
WAITING --> DONE
#+end_src
[[file:images/org_task_states.png][Org TODO task states]]

#+BEGIN_SRC emacs-lisp
(setq org-treat-insert-todo-heading-as-state-change t)  ;; to invoke timestamp log

(setq org-todo-keywords
      '((sequence "TODO(t!)" "NEXT(n)" "|" "DONE(d)")
	    (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)")))

(setq org-todo-keyword-faces
      '(("TODO" :foreground "red" :weight bold)
	    ("NEXT" :foreground "blue" :weight bold)
	    ("DONE" :foreground "forest green" :weight bold)
	    ("WAITING" :foreground "DeepPink4" :weight bold)
	    ("HOLD" :foreground "magenta" :weight bold)
	    ("CANCELLED" :foreground "forest green" :weight bold)))
#+END_SRC

For record purposes:
#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
#+END_SRC

Log state change notes and timestamps into drawer. Avoid cluttering my org entries.
#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer t)
#+END_SRC

Enforce TODO dependencies. To do A before B, before C, ... 
#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
#+END_SRC

Customise priority to allow for four options: #A, #B, #C, #D. #C is the default priority. #D for unimportant tasks. #B for important tasks. #A for top one priority.
#+BEGIN_SRC emacs-lisp
(setq org-highest-priority 65)
(setq org-lowest-priority 68)
(setq org-default-priority 67)
#+END_SRC

References:
1. https://orgmode.org/manual/Closing-items.html
   Org-log-done variable.
2. [[info:org#TODO%20dependencies][info:org#TODO dependencies]]
3. http://doc.norang.ca/org-mode.html#TasksAndStates

** Archiving Subtrees

Archiving can keep my main working files clutter-free. It keeps my files contributing to the agenda fairly current. It cleans up my project trees and removes the old tasks that are no longer interesting.

Tasks to archive are listed automatically at the end of agenda. They can have any todo state.
#+BEGIN_SRC emacs-lisp
(setq org-archive-mark-done nil)
(setq org-archive-location "%s_archive::* Archived Tasks")
#+END_SRC

** Org Time Clocking

#+BEGIN_SRC emacs-lisp
(setq org-clock-persist t)
(org-clock-persistence-insinuate)
#+END_SRC

Besides Bernt Hansen, Lee Hinman[fn:31] has good config on org-clocking. 
#+BEGIN_SRC emacs-lisp
;; Show lots of clocking history.
(setq org-clock-history-length 23) 

;; Removes clocked tasks with 0:00 duration. I want to clock only deep works.
(setq org-clock-out-remove-zero-time-clocks t) 

;; Set task to a special todo state while clocking it
(setq org-clock-in-switch-to-state "NEXT")

;; Insert clocking info into the drawer
(setq org-clock-into-drawer t)

;; Stop clocking when the task is marked DONE
(setq org-clock-out-when-done t)

;; Use UTF8 characters for clocktable
(setq org-pretty-entities t)
#+END_SRC

Open prompt to resolve clock if I idle more than 120 minutes.
#+BEGIN_SRC emacs-lisp
(setq org-clock-idea-time 120) ;; minutes
#+END_SRC

Use =org-mru-clock= package to clock into recent org-mode tasks. By default, org can clock into the last task. But sometimes I would like to clock into recent tasks.
#+BEGIN_SRC emacs-lisp
(require-package 'org-mru-clock)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-mru-clock-how-many 20)
(setq org-mru-clock-completing-read #'ivy-completing-read)
#+END_SRC

** Org-Gcal

Org sync with Google Calendar. 
#+BEGIN_SRC emacs-lisp
(require-package 'org-gcal) ;; https://github.com/kidd/org-gcal.el 
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'org-gcal)
(setq org-gcal-client-id (password-store-get-field "api/gcal-client" "client-id")
      org-gcal-client-secret (password-store-get-field "api/gcal-client" "client-secret"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-gcal-file-alist `((,(password-store-get-field "personal-info" "personal-gmail") . ,(jh/file-in-sync-directory "org" "gcal.txt"))))
#+END_SRC

Sync semi-automatically.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook (lambda () (org-gcal-sync) ))
;; (add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync) ))
;; (add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync) ))
#+END_SRC

References:
1. https://cestlaz.github.io/posts/using-emacs-26-gcal/

* Org Capture, Refile, Archive

** Org Capture

Set the default destination for notes captured.
#+BEGIN_SRC emacs-lisp
(setq org-default-notes-file (jh/file-in-sync-directory "org" "orgcapture.txt"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c c") 'org-capture)
#+END_SRC

Define org-capture-templates.
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      `(("t" "Org-capture for GTD")
        ("to" "Todo" entry (file+headline "" "Tasks")
         "* TODO %?\nCREATED: %U\n%i\n\n  " :prepend t :empty-lines 1)
        ("tt" "Task" entry (file+headline "" "Tasks")
         "* NEXT %?\n%t\n%i\n\n " :prepend t :clock-in t :clock-keep t)
        ("i" "An Idea to Explore" entry (file+headline "" "Ideas")
         "* %?\n%t\n%i\n\n ")
        ("j" "Journal" item (file+olp+datetree ,(jh/file-in-sync-directory "journal.txt")) "(%<%R>) %?\n%i\n" :empty-lines 1)
        ("e" "Engineering Journal" item (file+olp+datetree ,(jh/file-in-sync-directory "engineering_journal.txt")) "(%<%R>) %?\n%i\n" :empty-lines 1)
        ("p" "Punch In" entry (file+olp+datetree ,(jh/file-in-sync-directory "org" "gtd.org")) "* Daily Punch In" :clock-in t :clock-keep t :immediate-finish t)))
#+END_SRC

References:
1. https://orgmode.org/manual/Capture-templates.html
   Official docs. Taking it as a starting point.
2. https://www.reddit.com/r/emacs/comments/7zqc7b/share_your_org_capture_templates/duq0nnr

** Org Refile

#+BEGIN_SRC emacs-lisp
(defun jh/opened-buffer-files ()
  "Return the list of files currently opened in emacs"
 ) 
#+END_SRC

Refile to all org buffers, included current buffer and org-agenda-files.
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets
      '((org-buffer-list :maxlevel . 3)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-refile-use-outline-path t)
#+END_SRC

This is added because during refiling, my Ivy had an issue displaying all the options. All the options show as the same.
#+BEGIN_SRC emacs-lisp
;; Discussion: https://github.com/abo-abo/swiper/issues/1254
;; Solution: https://github.com/abo-abo/swiper/issues/444#issuecomment-286693939
(setq org-outline-path-complete-in-steps nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

Source: https://stackoverflow.com/a/26683663
#+BEGIN_SRC emacs-lisp
(defun jh/org-refile-to-datetree ()
  "Refile a subtree to a datetree corresponding to it's timestamp."
  (interactive)
  (let* ((datetree-date (org-entry-get nil "TIMESTAMP" t))
         (date (org-date-to-gregorian datetree-date)))
    (when date
      (save-excursion
        (org-cut-subtree)
        (org-datetree-find-date-create date)
        (org-narrow-to-subtree)
        (show-subtree)
        (org-end-of-subtree t)
        (newline)
        (goto-char (point-max))
        (org-paste-subtree 4)
        (widen)
        )
      )
    ))
#+END_SRC

References:
1. https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html

* Org Export

There is a need to format and share.

To export an Org-file into HTML file, install package =htmlize= to export Org file into HTML files. Then, export using an external CSS file instead of the original =inline-css= option.
#+BEGIN_SRC emacs-lisp
(require-package 'htmlize)
(setq org-html-htmlize-output-type 'css)
#+END_SRC

* Evil's Reading-State for Org-mode

Define an Evil's state for easy browsing, reading, and navigating in Org-mode. This serves as a higher level of abstraction over the NORMAL "mode" because like org-speed-key-commands, it offers quick keys to perform actions on the level of trees, subtrees, properties, tags, and org source blocks while the NORMAL "mode" navigates between lines. I think NORMAL "mode" is good for editing but what I want is a "mode" in Org-mode for reading. So I define an Evil state to achieve that.
#+BEGIN_SRC emacs-lisp
(evil-define-state reading
  "A state for reading, easy browsing, and quick navigation."
  :tag " <R> "
  :cursor hollow
  :message "-- READING --"
  (cond
   ((evil-reading-state-p)
    (set-cursor-color "gray")
    (evil-echo "-- READING --"))
   (t
    (evil-echo "-- NORMAL --")
    (set-cursor-color "#0FB300")))) ;; original theme color for cursor
#+END_SRC

Dependencies:
1. ivy
2. evil
3. 

#+BEGIN_SRC emacs-lisp
(defun jh/org-goto-first-child ()
  "Wrapper function for the original function."
  (interactive)
  (org-show-children) ;; expand tree
  (org-goto-first-child))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/outline-next-visible-heading (&optional count)
  "Essentially advise the outline-next-visible-heading function."
  (interactive "p")
  (outline-next-visible-heading 1)
  ;; (org-tree-to-indirect-buffer)
  (org-display-outline-path))

(defun jh/outline-previous-visible-heading (&optional count)
  "Essentially advise the outline-previous-visible-heading function."
  (interactive "p")
  (outline-previous-visible-heading 1)
  ;; (org-tree-to-indirect-buffer)
  (org-display-outline-path))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; ISSUE: The org-insert-heading does not detect that the cursor is at the beginning of line.
;; WORKAROUND: Force move the cursor to the beginning of line before inserting a new heading.
(defun jh/org-insert-heading-into-insert-state (&optional count)
  "Add a new sibling heading at the position of the current heading, and go into insert state."
  (interactive "p")
  (org-beginning-of-line) ;; force to the beginning of line.
  (org-insert-heading)
  (evil-insert-state))

(defun jh/org-insert-heading-after-current-into-insert-state (&optional count)
  "Add a new sibling heading and go into insert state."
  (interactive "p")
  (org-beginning-of-line) ;; force to the beginning of line.
  (org-insert-heading-after-current)
  (evil-insert-state))
#+END_SRC

Define all the keys for this "mode".
For headings:
#+BEGIN_SRC emacs-lisp
(define-key evil-reading-state-map (kbd "i") #'evil-normal-state)
(define-key evil-reading-state-map (kbd "h") #'outline-up-heading)
(define-key evil-reading-state-map (kbd "j") #'jh/outline-next-visible-heading)
(define-key evil-reading-state-map (kbd "k") #'jh/outline-previous-visible-heading)
(define-key evil-reading-state-map (kbd "l") #'jh/org-goto-first-child)
(define-key evil-reading-state-map (kbd "?\t") #'org-cycle)
;; (define-key evil-reading-state-map (kbd "") #')

(define-key evil-reading-state-map (kbd "o") #'jh/org-insert-heading-after-current-into-insert-state)
(define-key evil-reading-state-map (kbd "O") #'jh/org-insert-heading-into-insert-state)
#+END_SRC

For screen scrolling:
#+BEGIN_SRC emacs-lisp
(define-key evil-reading-state-map (kbd "f") #'evil-scroll-page-down)
(define-key evil-reading-state-map (kbd "b") #'evil-scroll-page-up)
(define-key evil-reading-state-map (kbd "<SPC>") #'evil-scroll-page-down)
(define-key evil-reading-state-map (kbd "<S-SPC>") #'evil-scroll-page-up)
#+END_SRC

For blocks:
#+BEGIN_SRC emacs-lisp
(define-key evil-reading-state-map (kbd "s") #'org-next-block)
(define-key evil-reading-state-map (kbd "r") #'org-previous-block)
(define-key evil-reading-state-map (kbd "'") #'org-edit-special)
#+END_SRC

For searches/filter:
#+BEGIN_SRC emacs-lisp
(define-prefix-command 'evil-reading-search-map)
(define-key evil-reading-state-map (kbd "/") #'evil-reading-search-map)
(define-key evil-reading-search-map (kbd "/") #'counsel-org-goto)
(define-key evil-reading-search-map (kbd "r") #'evil-search-forward)
#+END_SRC

#+RESULTS:
: evil-search-forward

#+BEGIN_SRC emacs-lisp
(define-key evil-reading-state-map (kbd "u") 'undo-tree-undo)
(define-key evil-reading-state-map (kbd ":") #'evil-ex)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/add-key-to-reading-state ()
  "A private function to add key to reading state."
  (evil-define-key 'normal org-mode-map (kbd "gr") #'evil-reading-state))

(add-hook 'org-mode-hook 'jh/add-key-to-reading-state)
#+END_SRC

References:
1. https://github.com/edwtjo/evil-org-mode/blob/master/evil-org.el
   The author defines an evil-org minor-mode. Bu it gives me an idea of simply defining a function and hook it to org-mode.
2. https://github.com/KNX32542/syndicate
   I didn't use this. But it might give a good customisation idea.
3. https://github.com/GuiltyDolphin/org-evil
   Or this. I didn't use this as well.
4. https://stackoverflow.com/a/4932922
   Cursor color.

* Emacs Research
** Ivy-bibtex

A bibliography manager based on Ivy.
#+BEGIN_SRC emacs-lisp
(require-package 'ivy-bibtex)
#+END_SRC

Pressing <enter> triggers the "default action". This is the default behaviour -- search for PDF to open, if not, its URL or DOI.
#+BEGIN_SRC emacs-lisp
(setq ivy-bibtex-default-action 'ivy-bibtex-open-any)
#+END_SRC

Specify the path to all .bib files.
#+BEGIN_SRC emacs-lisp
(defun get-all-bib-files ()
  "Get all my bib files under the directory recursively"
  (directory-files-recursively "/home/zacque/Documents/Artificial_Intelligence/academic_papers" "bib"))

(setq bibtex-completion-bibliography
      '("~/Documents/bibliography/references.bib"
	"~/Documents/Artificial_Intelligence/references.bib"))

(setq bibtex-completion-bibliography
      (append bibtex-completion-bibliography (get-all-bib-files)))
#+END_SRC

Specify the directories to search for PDFs.
#+BEGIN_SRC emacs-lisp
(defun get-all-subdirs ()
  "Get all subdirectories under the directory"
  (split-string (shell-command-to-string
    "find ~/Documents/Artificial_Intelligence/academic_papers/ -type d") "\n" t))

(setq bibtex-completion-library-path
      '("~/Documents/bibliography" "~/Documents/bibliography/pdfs/" "~/Documents/Artificial_Intelligence"))

(setq bibtex-completion-library-path
      (append bibtex-completion-library-path (get-all-subdirs)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq bibtex-completion-notes-path "/home/zacque/Documents/Artificial_Intelligence/academic_papers/notes.org")
#+END_SRC

References:
1. https://github.com/tmalsburg/helm-bibtex/tree/e1391a4be629b506f06d678bcdfd17d290904482

** ebib

I discover that ~ivy-bibtex~ works with ~ebib~.
#+BEGIN_SRC emacs-lisp
(require-package 'ebib)
#+END_SRC

Launch ~ebib~ in evil-emacs-state.
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'ebib-index-mode 'emacs)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq ebib-file-search-dirs '(""))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (setq ebib-preload-bib-files bibtex-completion-bibliography)
(setq ebib-preload-bib-files (list "/home/zacque/Documents/Artificial_Intelligence/references.bib" "/home/zacque/Documents/bibliography/references.bib" "/home/zacque/Documents/Artificial_Intelligence/academic_papers/computer_vision/references.bib" "/home/zacque/Documents/Artificial_Intelligence/academic_papers/instance_segmentation/references.bib" "/home/zacque/Documents/Artificial_Intelligence/academic_papers/video_understanding/references.bib"))
#+END_SRC

Load the provided ~org~ebib~ package to provide org-mode integration. E.g. ebib org-link-type.
#+BEGIN_SRC emacs-lisp
(require 'org-ebib)
#+END_SRC

*** Archived                                                     :noexport:
:PROPERTIES:
:header-args: :tangle no
:END:

[Archived] Integrate ebib link to org-mode.
Status: Archived
Reason: Load the provided ~org-ebib~ package will do.
#+BEGIN_SRC emacs-lisp
(org-add-link-type "ebib" 'ebib)
#+END_SRC

References:
1. https://stackoverflow.com/a/14984481
   Add org link type.

** Org-ref

=org-ref= is an Emacs library/org-mode modules for citations, cross-references, bibliographies and other useful bibtext tools.

#+BEGIN_SRC emacs-lisp
(setq org-ref-completion-library 'org-ref-ivy-cite)
#+END_SRC

This matches the APA citation style that I usually use.
#+BEGIN_SRC emacs-lisp
(setq org-ref-default-citation-link "Citep")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq reftex-default-bibliography
      '("~/Documents/bibliography/references.bib"
        "~/Documents/Artificial_Intelligence/references.bib"))
#+END_SRC

Not quite sure the differences between these and the =reftex-default-bibliography= variable.
#+BEGIN_SRC emacs-lisp
(setq org-ref-bibliography-notes "~/Documents/bibliography/notes.txt"
      org-ref-default-bibliography reftex-default-bibliography
      org-ref-pdf-directory "~/Documents/bibliography/pdfs/")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require-package 'org-ref)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/add-bib-to-org-ref ()
  "Add the current .bib file to org-ref."
  (interactive)
  (unless (buffer-file-name)
    (error "No file is being viewed."))
  (add-to-list 'org-ref-default-bibliography (buffer-file-name)))
#+END_SRC

To open org pdf link with Emacs pdf tools. Reference: https://github.com/jkitchin/org-ref/issues/184#issuecomment-303553448
#+BEGIN_SRC emacs-lisp
(setq org-file-apps 
      '((auto-mode . emacs)
        ("\\.mm\\'" . default)
        ("\\.x?html?\\'" . default)
        ("\\.pdf\\'" . emacs)))
#+END_SRC

To compile LaTeX document with citations:
#+BEGIN_SRC emacs-lisp
(setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-latex-logfiles-extensions  '("lof" "lot" "tex" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl" "pygtex" "pygstyle"))
#+END_SRC

#+Source: https://tex.stackexchange.com/a/372988
#+BEGIN_SRC emacs-lisp
(setq tex-run-command "pdftex")
(setq tex-bibtex-command "biber")
(setq latex-run-command "pdflatex")
#+END_SRC

#+RESULTS: https://tex.stackexchange.com/a/372988
: pdflatex

References:
1. https://nickgeorge.net/science/org_ref_setup/
** Arxiv

Load the library to enable arxiv org-link support, e.g. arxiv:0801.1144.
#+BEGIN_SRC emacs-lisp
(require 'org-ref-arxiv)
#+END_SRC

References:
1. http://kitchingroup.cheme.cmu.edu/blog/2015/03/09/Bibtex-Entries-from-Arxiv-org/

* Projectile Mode

A package for project management and navigation.
#+BEGIN_SRC emacs-lisp
(require-package 'projectile)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-p") 'projectile-command-map)

;; Shorter modeline
(setq-default projectile-mode-line-prefix " Proj")
(setq projectile-completion-system 'ivy)
(projectile-mode +1)
#+END_SRC

Extra:
1. [[Ripgrep Package][Integration with Ripgrep Package]]
   Install the ripgrep package.

Note:
1. Check out counsel-projectile package for customisation code guidance.

Customisation idea:
1. Use rg search by default, coupled with ivy completing system.

* SQL Database

Emacs has a built-in SQL suite that includes SQL highlighting and SQL consoles for all major players: SQL mode and a function =sql-ms= that can connect to a database.

It depends on the =osql= and =isql= program. This can be installed on Ubuntu.
#+BEGIN_SRC sh :dir /sudo::
sudo apt install freetds-bin unixodbc
#+END_SRC

* Enable Yasnippet Templating

=Yasnippet= is a templating tool to save boilerplate typing, such as a file header. It is very powerful and the template can even be defined dynamically.
#+BEGIN_SRC emacs-lisp
(require-package 'yasnippet)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(yas-reload-all)
(diminish 'yas-minor-mode  " Ⓨ")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(dolist (hook '(text-mode-hook prog-mode-hook))
  (add-hook hook 'yas-minor-mode))
#+END_SRC

* GNU Global

#+BEGIN_SRC emacs-lisp
(require-package 'ggtags)
#+END_SRC

* Org Literate Programming/ Org-babel/ Ox-babel

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
#+END_SRC

Disabling default source code block indentation by 2 spaces (relative to the #+BEGIN_SRC and #+END_SRC lines) makes direct editing much easier [fn:11].
#+BEGIN_SRC emacs-lisp
(setq org-edit-src-content-indentation 0)
#+END_SRC

Edit org-src-code on the other window, instead of force organising all the frame into two side-by-side window.
#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'other-window)
#+END_SRC

Use org template system to generate source blocks.
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist '("es" "#+BEGIN_SRC emacs-lisp?\n#+END_SRC"))
(add-to-list 'org-structure-template-alist '("py" "#+BEGIN_SRC python\n?\n#+END_SRC"))
(add-to-list 'org-structure-template-alist '("sh" "#+BEGIN_SRC shell\n?\n#+END_SRC"))
(add-to-list 'org-structure-template-alist '("jp" "#+BEGIN_SRC jupyter-python\n?\n#+END_SRC"))
(add-to-list 'org-structure-template-alist '("di" "#+BEGIN_SRC ditaa :file ?.png :cmdline -r -s 0.8\n\n#+END_SRC"))
(add-to-list 'org-structure-template-alist '("dot" "#+BEGIN_SRC dot :file ?.png :cmdline -Kdot -Tpng\n\n#+END_SRC"))
(add-to-list 'org-structure-template-alist '("pl" "#+BEGIN_SRC plantuml :file ?.png \n\n#+END_SRC"))
#+END_SRC

Instead of replace the file content on every tangle, use this to append code to the file.
#+BEGIN_SRC emacs-lisp :tangle no
;; SOURCE: https://emacs.stackexchange.com/a/38898
(defun org-babel-tangle-append ()
  "Append source code block at point to its tangle file.
   The command works like `org-babel-tangle' with prefix arg
   but `delete-file' is ignored."
  (interactive)
  (cl-letf (((symbol-function 'delete-file) #'ignore))
    (org-babel-tangle '(4))))
(add-hook 'org-mode-hook #'org-babel-tangle-append)
#+END_SRC

Auto-display generated image after each execution. This is especially useful for ob-jupyter, ob-ditaa, Graphviz and PlantUML. Source: https://github.com/dzop/emacs-jupyter/issues/178
#+BEGIN_SRC emacs-lisp
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+END_SRC

** ob-async

Run ob-babel asynchronously. I hope this could be the default behaviour?
#+BEGIN_SRC emacs-lisp
(require-package 'ob-async)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq ob-async-no-async-languages-alist '("jupyter-python" "jupyter-julia"))
#+END_SRC

Note:
1. The package does not support :session header-arg for now. See github:astahlman/ob-async#1.

References:
1. github:astahlman/ob-async

** emacs-jupyter

*** System Setup
:PROPERTIES:
:header-args: :tangle no
:END:

Prerequisite:
#+BEGIN_SRC shell :dir /sudo::
apt-get install -y python3-ipykernel
#+END_SRC

#+BEGIN_SRC shell :dir /sudo::
pip3 install ipykernel
#+END_SRC

#+BEGIN_SRC shell :dir /sudo::
python3 -m ipykternel.kernelspec
#+END_SRC

#+RESULTS:
: Installed kernelspec python3 in /usr/local/share/jupyter/kernels/python3

Edit kernel.json file to using python3.
#+BEGIN_SRC shell
jupyter kernelspec list
#+END_SRC

Refresh Emacs Jupyter config if necessary.
#+BEGIN_SRC emacs-lisp
(jupyter-available-kernelspecs t)
#+END_SRC

*** Connect to remote kernel
:PROPERTIES:
:header-args: :tangle no
:END:

#+BEGIN_SRC shell
jupyter kernel --kernel=python3
#+END_SRC

*** Emacs Setup

#+BEGIN_SRC emacs-lisp
(require-package 'jupyter)
#+END_SRC

** Load all babel

List the supported language for org-babel.
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((R . t)
   (ditaa . t)
   (dot . t)
   (emacs-lisp . t)
   (gnuplot . t)
   (haskell . nil)
   (latex . t)
   (ledger . t)
   (ocaml . nil)
   (octave . t)
   (plantuml . t)
   (python . t)
   (ruby . t)
   (screen . nil)
   (shell . t)
   (sql . nil)
   (sqlite . t)
   (scheme . t)
   (C . t)
   (jupyter . t))) ;; jupyter should be the last
#+END_SRC

* Parentheses Fun

A section about parentheses and lisp modes in general. Might deal with parens, quotes,and mode.

#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0)
#+END_SRC

Activate this mode (globally?) to highlight matching parenthsis.
#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
#+END_SRC

Reference: https://emacs.stackexchange.com/q/28857 and https://stackoverflow.com/q/27142996
#+BEGIN_SRC emacs-lisp
;; Purcell .emacs.d
(when (fboundp 'electric-pair-mode)
  (add-hook 'after-init-hook 'electric-pair-mode)
  (setq electric-pair-preserve-balance nil))
#+END_SRC

** Rainbow-Delimiters

#+BEGIN_SRC emacs-lisp
(require-package 'rainbow-delimiters)
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+END_SRC

** Paredit

A mode that enables AST transformation.
#+BEGIN_SRC emacs-lisp
(require-package 'paredit)
(diminish 'paredit " Par")
#+END_SRC

** Lispy Hooks

Check parens on save. Taken from Purcell.
#+BEGIN_SRC emacs-lisp
(defun jh/enable-check-parens-on-save ()
  "Run `check-parens' when the current buffer is saved."
  (add-hook 'after-save-hook #'check-parens nil t))
#+END_SRC

Adapt evil-args to lisp. 
Issues: 
1. Have to consider the spaces in strings.
2. Have to consider arguments between newline characters as well. (applied to c-modes)
#+NAME: evil-lisp-args
#+BEGIN_SRC emacs-lisp
(defun jh/evil-args-switch-to-lisp-mode ()
  "Switch evil-args parameters to adapt to lisp-modes."
  (setq evil-args-delimiters '(" ")))
#+END_SRC

Define all hooks to run in all Lisp modes based on Purcell's config.
#+BEGIN_SRC emacs-lisp
(defvar jh/lispy-modes-hook
  '(jh/enable-check-parens-on-save
    jh/evil-args-switch-to-lisp-mode
    enable-paredit-mode
    aggressive-indent-mode)
  "Define all hooks to run in all Lisp modes.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/lisp-setup()
  "Enable features useful in all Lisp modes."
  (run-hooks 'jh/lispy-modes-hook))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defconst jh/lispy-modes
  '(lisp-mode lisp-interaction-mode inferior-lisp-mode
              emacs-lisp-mode common-lisp-mode geiser-mode)
  "All lisp modes.")
#+END_SRC

An in-built Elisp library.
#+BEGIN_SRC emacs-lisp
(require 'derived)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(dolist (hook (mapcar #'derived-mode-hook-name jh/lispy-modes))
  (add-hook hook 'jh/lisp-setup))
#+END_SRC

* Emacs Lisp

Taken from Purcell. This package might prettier elisp expessions output.
#+BEGIN_SRC emacs-lisp
(require-package 'ipretty)
(add-hook 'after-init-hook 'ipretty-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require-package 'highlight-quoted)
(add-hook 'emacs-lisp-mode-hook 'highlight-quoted-mode)
#+END_SRC

Kill the debugger windows on exit.
#+BEGIN_SRC emacs-lisp
(setq debugger-bury-or-kill 'kill)
#+END_SRC

* Enable Geiser Mode
  
The official website is here [fn:7]. 
#+BEGIN_SRC emacs-lisp
(require-package 'geiser)
#+END_SRC
  
Set guile as the default choice. No need to ask for confirmation everytime.
#+BEGIN_SRC emacs-lisp
(setq geiser-active-implementations '(guile))
#+END_SRC

Configure org-tangle to export scheme file to end with .scm. By default, it ends with .scheme extension.
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-babel-tangle-lang-exts '("scheme" . "scm"))
#+END_SRC

* Enable Web-Mode

#+BEGIN_SRC emacs-lisp
(require-package 'web-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq web-mode-enable-current-element-highlight t)
#+END_SRC

This web-mode uses =evil-matchit= package to jump between closing and opening HTML tags.

* Enable PHP-Mode

#+BEGIN_SRC emacs-lisp
(require-package 'php-mode)
#+END_SRC

* Enable Python-Mode

On Ubuntu, use Python3 by default.
#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "python3")
#+END_SRC

In Ubuntu, set org-babel to run =python3= by default.
#+BEGIN_SRC emacs-lisp
(setq org-babel-python-command "python3")
#+END_SRC

** Highlight Indentation

Enable highlight indentation globally.
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'highlight-indentation-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'highlight-indentation
  (diminish 'highlight-indentation-mode))
#+END_SRC

** Pip-mode

It supports =*.pip= and =requirements*.txt= files. It provides syntax highlighting, togglable comments, and auto-completion of package names from PyPI.

#+BEGIN_SRC emacs-lisp
(require-package 'pip-requirements)
#+END_SRC

[Workaround] Not sure why the mode does not auto-detect "requirements.txt" file.
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("requirements.txt" . pip-requirements-mode))
#+END_SRC

References:
1. https://github.com/Wilfred/pip-requirements.el

** Elpy

Elpy turns Emacs into a Python IDE. Getting ideas from these sources [fn:9].
#+BEGIN_SRC emacs-lisp
(require-package 'elpy) ;; Python IDE features
#+END_SRC

It relies on =Jedi= for backend introspection and analysis of Python sources. Jedi is known to have problems coping with badly-formatted Python.
#+BEGIN_SRC shell :dir /sudo::
pip install jedi flake8
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq elpy-rpc-python-command "python3")
(setq elpy-rpc-virtualenv-path 'current)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jh/--enable-elpy ()
  (elpy-enable))
(add-hook 'python-mode-hook #'jh/--enable-elpy)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key elpy-mode-map [remap elpy-shell-kill-all] nil)
#+END_SRC

These are packages that work well with Elpy:
1. flycheck (as the Flymake alternative)
   #+BEGIN_SRC emacs-lisp
   (when (require 'flycheck nil t)
       (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
       (add-hook 'elpy-mode-hook 'flycheck-mode))
   #+END_SRC

2. py-autopep8
   #+BEGIN_SRC emacs-lisp
   (require-package 'py-autopep8)
   (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
   #+END_SRC

3. ein (Ipython/Jupyter integration)
   #+BEGIN_SRC emacs-lisp :tangle no
   (elpy-use-ipython)
   #+END_SRC

Error: elpy-use-ipython is deprecated; see https://elpy.readthedocs.io/en/latest/ide.html#interpreter-setup

** Jupyter

To use Emacs with Jupyter, check out =emacs-jupyter=, =ob-ipython=, and =ein=.

* Enable YAML Mode

This is useful to edit =docker-compose.yml= file.
#+BEGIN_SRC emacs-lisp
;; YAML Mode
(require-package 'yaml-mode)
(add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))

(add-hook 'yaml-mode-hook
	  '(lambda ()
	     (define-key yaml-mode-map "\C-m" 'newline-and-indent)))
#+END_SRC

** Readable YAML

To make YAML readable:
1. Highlight indentation.
   #+BEGIN_SRC emacs-lisp
   (add-hook 'yaml-mode-hook 'highlight-indentation-mode)
   #+END_SRC
   Refer to: [[*Highlight Indentation][Highlight Indentation in Python Mode]]

2. Folds all code on an higher indentation level to view the outline.
   #+BEGIN_SRC emacs-lisp
   ;; Source: https://stackoverflow.com/a/4459159
   (defun aj-toggle-fold (&optional arg)
     "Toggle fold all lines larger than indentation on current line"
     (interactive)
     (let ((col 1))
       (save-excursion
         (back-to-indentation)
         (setq col (+ 1 (current-column)))
         (set-selective-display
          (if selective-display nil (or col 1))))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (defun evil-yaml-mode ()
     "Override default evil key bindings for yaml mode."
     (evil-define-key 'normal yaml-mode-map
       "za" 'aj-toogle-fold))

   (add-hook 'yaml-mode-hook 'evil-yaml-mode)
   #+END_SRC

References:
1. https://blog.chmouel.com/2016/09/07/dealing-with-yaml-in-emacs/

* Enable Rust-Mode

#+BEGIN_SRC emacs-lisp
(require-package 'rust-mode)
#+END_SRC

Automatic runs =rust-format-buffer= during saves. By default, it is bound to =C-c C-f=.
#+BEGIN_SRC emacs-lisp
(setq rust-format-on-save t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require-package 'flycheck-rust)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
#+END_SRC

** Ob-Rust

[Prerequisite] Install =rust=, =cargo=, and =cargo-script=.
#+BEGIN_SRC shell
cargo install cargo-script
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require-package 'ob-rust)
#+END_SRC

* Enable Groovy Mode for Gradle

Gradle is Groovy DSL.

#+BEGIN_SRC emacs-lisp
(require-package 'groovy-mode)
#+END_SRC

** Define a derived gradle-mode
:PROPERTIES:
:header-args: :tangle ./lisp/gradle-mode/gradle-mode.el
:END:

Derive and define gradle-mode from groovy-mode. Note: This code will be tangled to the lisp dir.
#+BEGIN_SRC emacs-lisp
;;; gradle-mode.el --- An emacs major mode for editing gradle files.

;; Copyright (C) 2019  Lee Jia Hong

;; Author: Lee Jia Hong
;; Keywords: languages
;; Version: 0.0.1

;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.

;;; Commentary:

;; A mode for editing gradle files.
;;

;;; Code:
(require 'groovy-mode)

(defvar gradle-constants '())

(defvar gradle-keywords '())

(defvar gradle-tab-width 4 "Width for a tab for gradle mode")

(defvar gradle-font-lock-defaults '(()))

(add-to-list 'auto-mode-alist '("\.gradle$" . gradle-mode))

(define-derived-mode gradle-mode groovy-mode "Gradle mode"
  "Gradle mode is a major mode for editing gradle file"
  (setq font-lock-defaults groovy-font-lock-keywords)

  (when gradle-tab-width
    (setq tab-width gradle-tab-width))

  (setq comment-start "//")
  (setq comment-end "")
)

(provide 'gradle-mode)
;;; gradle-mode.el ends here
#+END_SRC

** Gradle-mode

#+BEGIN_SRC emacs-lisp :tangle no
(require 'gradle-mode)
#+END_SRC

* Enable BNF-Mode

For editing BNF grammars.
#+BEGIN_SRC emacs-lisp
(require-package 'bnf-mode)
#+END_SRC

References:
1. https://github.com/sergeyklay/bnf-mode

* Enable ini-mode

#+BEGIN_SRC emacs-lisp
(require 'ini-mode)
(add-to-list 'auto-mode-alist '("\\.ini\\'" . ini-mode))
#+END_SRC

References:
1. https://github.com/Lindydancer/ini-mode

* Enable toml-mode

#+BEGIN_SRC emacs-lisp
(require-package 'toml-mode)
#+END_SRC

* Graphviz and PlantUML

** Graphviz

#+BEGIN_SRC emacs-lisp
(require-package 'graphviz-dot-mode)
#+END_SRC

** PlantUML

#+BEGIN_SRC emacs-lisp
(require-package 'plantuml-mode)
#+END_SRC

#+SOURCE: Purcell .emacs.d
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ob-plantuml
  (let ((jar-name "plantuml.jar")
        (url "http://jaist.dl.sourceforge.net/project/plantuml/plantuml.jar"))
    (setq org-plantuml-jar-path (expand-file-name jar-name (file-name-directory user-init-file)))
    (unless (file-exists-p org-plantuml-jar-path)
      (url-copy-file url org-plantuml-jar-path))))
#+END_SRC

** Ditaa

#+BEGIN_SRC emacs-lisp
(setq org-ditaa-jar-path (jh/emacs-subdirectory "ditaa.jar"))
#+END_SRC

#+RESULTS:
: /home/zacque/.emacs.d/ditaa.jar

* Docker -- Containers

Surprisingly, there are Emacs packages that offer a nice integration with Docker to help manage containers. 

=docker= package offers a Magit-like hydra menu to handle images and containers from Emacs. =dockerfile-mode= offers syntax highlighting when editing Dockerfiles. =docker-tramp= allows me to connect via TRAMP to the insides of a container and do whatever I need there.

#+BEGIN_SRC emacs-lisp
(require-package 'docker)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq docker-command "/usr/bin/docker")
#+END_SRC

Make =evil= works well with =docker= mode.
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'docker-container-mode 'emacs)
(evil-set-initial-state 'docker-network-mode 'emacs)
(evil-set-initial-state 'docker-image-mode 'emacs)
#+END_SRC

Since I didn't add my user to the Docker group, I will need to run every docker command with =sudo=. Setting this flag will make it work. [fn:17]
#+BEGIN_SRC emacs-lisp
(setq docker-run-as-root nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require-package 'dockerfile-mode)
(add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require-package 'docker-compose-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(fullframe docker-images tablist-quit)
(fullframe docker-machines tablist-quit)
(fullframe docker-volumes tablist-quit)
(fullframe docker-networks tablist-quit)
(fullframe docker-containers tablist-quit)
#+END_SRC

Map <RET> to a key to show all options. By default, pressing <RET> does nothing, which is unintuitive to me.
#+BEGIN_SRC emacs-lisp
(define-key docker-container-mode-map (kbd "RET") 'docker-container-help-popup)
#+END_SRC

* Magit -- Git Client

** Magit 

#+BEGIN_SRC emacs-lisp
(require-package 'magit)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(fullframe magit-status magit-mode-quit-window)
#+END_SRC

** Forge -- Working with GitHub and GitLab

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'magit
  (require-package 'forge))
#+END_SRC

* Eglot -- LSP Client

Eglot is a Language Server Protocol(LSP) server client. It has default integration with flymake and is aiming to be integrated into Emacs.
#+BEGIN_SRC emacs-lisp
(require-package 'eglot)
#+END_SRC

Automatically shutdown Eglot after the last managed buffer is killed. Checkout: github:joaotavora/eglot#305
#+BEGIN_SRC emacs-lisp
(setq eglot-autoshutdown t)
#+END_SRC

Currently, I have installed Python Language Server [fn:21] and Rust Language Server [fn:22]. Autorun =eglot= when visiting these buffers.
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'eglot-ensure)
(add-hook 'rust-mode-hook 'eglot-ensure)
#+END_SRC

* Restclient for Testing API

#+BEGIN_SRC emacs-lisp
(require-package 'restclient)
(require-package 'ob-restclient)
#+END_SRC

Load org-babel for restclient. 
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages '((restclient . t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require-package 'company-restclient)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'company-backends 'company-restclient)
#+END_SRC

* Terraform

Major mode for terraform configuration file.
#+BEGIN_SRC emacs-lisp
(require-package 'terraform-mode)
#+END_SRC

Company backend for terraform files.
#+BEGIN_SRC emacs-lisp
(require-package 'company-terraform)
(company-terraform-init)
#+END_SRC

References:
1. https://github.com/syohex/emacs-terraform-mode
2. https://github.com/rafalcieslak/emacs-company-terraform

** Archived                  :noexport:
:PROPERTIES:
:header-args: :tangle no
:END:

*** Terraform-doc

[Archived] Lookup docs from Terraform homepage.
Reason: Replace by dash docs.
#+BEGIN_SRC emacs-lisp
(require-package 'terraform-doc)
#+END_SRC

References: 
1. https://github.com/TxGVNN/terraform-doc

* Writing Experience

** Writing in Chinese Pinyin

Writing in Chinese pinyin [fn:18]. Use =set-input-method= to switch between languages. Use =toggle-input-method= to easily switch back.
#+BEGIN_SRC emacs-lisp
(require-package 'pyim)
(require 'pyim)
#+END_SRC

Pinyin dictionary for =pyim= package.
#+BEGIN_SRC emacs-lisp
(require-package 'pyim-basedict)
(pyim-basedict-enable)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq pyim-dicts `((:name "hugedict" :file ,(jh/emacs-subdirectory "pyim/dict/pyim-bigdict.pyim"))))
#+END_SRC

Use "pyim" as default input method. Then I can invoke =toggle-input-method= anywhere to type Chinese.
#+BEGIN_SRC emacs-lisp
(setq default-input-method "pyim")
#+END_SRC

** Spelling Checker (Flyspell-mode)

Flyspell-mode is a built-in package with Emacs.
#+BEGIN_SRC emacs-lisp
(require 'flyspell)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook #'flyspell-mode)
#+END_SRC

I prefer British spelling to US spelling.
#+BEGIN_SRC emacs-lisp
(setq ispell-dictionary "british-ise")
#+END_SRC

Remove the default "M-TAB" binding to flyspell-auto-correct-word. Currently, I am using it for pcomplete.
#+BEGIN_SRC emacs-lisp
(define-key flyspell-mode-map (kbd "C-M-i") nil)
#+END_SRC

** Whitespace Alignment

Source: http://pragmaticemacs.com/emacs/aligning-text/
#+BEGIN_SRC emacs-lisp
(defun jh/align-whitespace (start end)
  "Align columns by whitespace."
  (interactive "r")
  (align-regexp start end "\\(\\s-*\\)\\s-" 1 0 t))
#+END_SRC

* Managing System Services

Managing system services through Emacs.
#+BEGIN_SRC emacs-lisp
(require-package 'daemons)

(evil-set-initial-state 'daemons-mode 'emacs)
(evil-set-initial-state 'daemons-output-mode 'emacs)

(fullframe daemons quit-window)
#+END_SRC

* Emacs Buffers

** ibuffer

#+BEGIN_SRC emacs-lisp
(require 'ibuffer)
#+END_SRC

ibuffer is an in-built package. Use ibuffer to manage buffer.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(fullframe ibuffer ibuffer-quit)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Use human readable Size column instead of original one
(define-ibuffer-column size-h
  (:name "Size" :inline t)
  (file-size-human-readable (buffer-size)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Modify the default ibuffer-formats (toggle with `)
(setq ibuffer-formats
      '((mark modified read-only vc-status-mini " "
              (name 22 22 :left :elide)
              " "
              (size-h 9 -1 :right)
              " "
              (mode 12 12 :left :elide)
              " "
              vc-relative-file)
        (mark modified read-only vc-status-mini " "
              (name 22 22 :left :elide)
              " "
              (size-h 9 -1 :right)
              " "
              (mode 14 14 :left :elide)
              " "
              (vc-status 12 12 :left)
              " "
              vc-relative-file)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(setq ibuffer-filter-group-name-face 'font-lock-doc-face)
#+END_SRC

** ibuffer-vc

Group buffers by vc root directory.
#+BEGIN_SRC emacs-lisp
(require-package 'ibuffer-vc)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun ibuffer-set-up-preferred-filters ()
  (ibuffer-vc-set-filter-groups-by-vc-root)
  (unless (eq ibuffer-sorting-mode 'filename/process)
    (ibuffer-do-sort-by-filename/process)))

(add-hook 'ibuffer-hook 'ibuffer-set-up-preferred-filters)
#+END_SRC

* Emacs Windows

** ace-window

Quick switching between buffer windows.
#+BEGIN_SRC emacs-lisp
(require-package 'ace-window)
(ace-window-display-mode 1) ;; show keys in the modeline
(global-set-key [remap other-window] 'ace-window)
#+END_SRC

** Hydra -- tying it all

#+BEGIN_SRC emacs-lisp
(defhydra hydra-window-z ()
  "Hydra-window"
  ("h" windmove-left)
  ("j" windmove-down)
  ("k" windmove-up)
  ("l" windmove-right)

  ("H" buf-move-left)
  ("J" buf-move-down)
  ("K" buf-move-up)
  ("L" buf-move-right)

  ("1" ace-window "ace")
  ("s" (lambda () (interactive) (ace-window 4)) "swap")
  ("d" (lambda () (interactive) (ace-window 16)) "delete")

  ("|" (lambda ()
	 (interactive)
	 (split-window-right)
	 (windmove-right)))
  ("-" (lambda ()
	 (interactive)
	 (split-window-below)
	 (windmove-down)))
  ("u" (progn
	 (winner-undo)
	 (setq this-command 'winner-undo)))
  ("f" counsel-find-file)
  ("r" winner-redo)
  ("d" delete-window))

(global-set-key (kbd "<f1>") 'hydra-window-z/body)
#+END_SRC

References:
1. https://www.reddit.com/r/emacs/comments/8of6tx/tip_how_to_be_a_beast_with_hydra/e059v1z/
2. https://oremacs.com/2015/01/29/more-hydra-goodness/
   Combining ace-window and windmove with hydra.

* EXWM -- Use Emacs as a Window Manager

** Basic Setup

#+BEGIN_SRC emacs-lisp
(require-package 'exwm)
(require 'exwm-config)
#+END_SRC

Show all EXWM buffers in all workspaces.
#+BEGIN_SRC emacs-lisp
(setq exwm-workspace-show-all-buffers t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq exwm-layout-show-all-buffers t)
#+END_SRC

Able to resize non-floating buffer with mouse.
#+BEGIN_SRC emacs-lisp
(window-divider-mode)
#+END_SRC

** Utils

#+BEGIN_SRC emacs-lisp
(defun switch-to-last-buffer ()
  "Switch to last open buffer in current window."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(exwm-input-set-key (kbd "s-<tab>") #'switch-to-last-buffer)
#+END_SRC

** Auto-Generate an Appropriate Name to Each EXWM Buffer

#+BEGIN_SRC emacs-lisp
(add-hook 'exwm-update-class-hook
          (lambda ()
            (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-class-name))))
(add-hook 'exwm-update-title-hook
          (lambda ()
            (when (or (not exwm-instance-name)
                      (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                      (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-title))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'exwm-update-title-hook (lambda () (exwm-workspace-rename-buffer exwm-title)))
#+END_SRC

Note: This function keeps giving out-of-range errors with pop-up windows.
#+BEGIN_SRC emacs-lisp :tangle no
;; SOURCE: https://github.com/ch11ng/exwm/issues/365#issuecomment-368338923
(defun exwm-rename-buffer ()
  "Rename buffers to X window titles."
  (interactive)
  (exwm-workspace-rename-buffer
   (concat exwm-class-name ": "
	   (if (<= (length exwm-title) 16) exwm-title
	     (concat (substring exwm-title 0 20) "...")))))
(add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
(add-hook 'exwm-update-title-hook 'exwm-rename-buffer)
#+END_SRC

References:
1. https://github.com/ch11ng/exwm/wiki/Configuration-Example

** RandR (Multi-screen)

#+BEGIN_SRC emacs-lisp
(require 'exwm-randr)
#+END_SRC

The number of workspace should not be less than the number of monitors.
#+BEGIN_SRC emacs-lisp
(setq exwm-workspace-number 2)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq exwm-randr-workspace-output-plist '(1 "eDP-1-1" 0 "HDMI-1-2"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'exwm-randr-screen-change-hook
          (lambda ()
            (start-process-shell-command
             "xrandr" nil "xrandr --output eDP-1-1 --primary --output HDMI-1-2 --rotate left --right-of eDP-1-1 --auto")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(exwm-randr-enable)
#+END_SRC

** Run Command Apps from EXWM

#+BEGIN_SRC emacs-lisp
;; USE EXWM KEY TO RUN COMMANDS
;; SOURCE: https://github.com/vbuaraujo/emacs-configs/blob/master/init-exwm.el
(defun exwm-command-shortcut (key command)
  (exwm-input-set-key key
		      `(lambda ()
			 (interactive)
			 (start-process "exwm-shortcut" nil "sh" "-c" ,command))))
#+END_SRC

[Obsolete] I used to open terminal using the combination <START>-t. Now, I seek to work with eshell.

#+BEGIN_SRC emacs-lisp :tangle no
(exwm-command-shortcut (kbd "s-t") "xfce4-terminal")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-t") 'vterm)
#+END_SRC

** Run Linux Apps from Emacs

#+BEGIN_SRC emacs-lisp
;; Shortcut Key
(exwm-input-set-key (kbd "s-SPC") 'counsel-linux-app)
#+END_SRC

** Simulate Keys to X11

Note: EXWM or X11 related key are defined with Super perfix key.

#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-i") 'exwm-input-toggle-keyboard)
(exwm-input-set-key (kbd "s-w") 'exwm-workspace-switch)
(exwm-input-set-key (kbd "s-r") 'rename-buffer)
(exwm-input-set-key (kbd "s-m") 'exwm-workspace-move-window)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; https://www.reddit.com/r/emacs/comments/6huok9/exwm_configs/dkvt5bs
(exwm-input-set-key (kbd "s-h") #'windmove-left)
(exwm-input-set-key (kbd "s-j") #'windmove-down)
(exwm-input-set-key (kbd "s-k") #'windmove-up)
(exwm-input-set-key (kbd "s-l") #'windmove-right)
#+END_SRC

Check out: Hydra + Ace-window. https://www.youtube.com/watch?v=_qZliI1BKzI
#+BEGIN_SRC emacs-lisp
(require 'buffer-move)
(exwm-input-set-key (kbd "s-C-h") #'buf-move-left)
(exwm-input-set-key (kbd "s-C-j") #'buf-move-down)
(exwm-input-set-key (kbd "s-C-k") #'buf-move-up)
(exwm-input-set-key (kbd "s-C-l") #'buf-move-right)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
;; SOURCE: https://github.com/ch11ng/exwm/wiki/Configuration-Example
(setq exwm-input-simulation-keys
      '(
	;; ;; movement
	;; ([?\C-b] . [left])
	;; ([?\M-b] . [C-left])
	;; ([?\C-f] . [right])
	;; ([?\M-f] . [C-right])
	;; ([?\C-p] . [up])
	;; ([?\C-n] . [down])
	;; ([?\C-a] . [home])
	;; ([?\C-e] . [end])
	;; ([?\M-v] . [prior])
	;; ([?\C-v] . [next])
	;; ([?\C-d] . [delete])
	;; ([?\C-k] . [S-end delete])

	([?\C-c C-c] . [?\C-c])

	;; cut/paste.
	([?\M-w] . [?\C-c])
	([?\C-y] . [?\C-v])))
#+END_SRC

** EXWM Enable

#+BEGIN_SRC emacs-lisp
(exwm-enable)
#+END_SRC

* File and Directory

In this section, I'll configure the regarding files editing, reading, and directory operations.

** Dired Configuration

#+BEGIN_SRC emacs-lisp
(require 'dired)
#+END_SRC

Set the default dired target to an adjacent dired buffer location.

#+BEGIN_SRC emacs-lisp
(setq-default dired-dwim-target t)
#+END_SRC

Change dired default sorting to directories first, then followed by files in alphabetical order [fn:3].

#+BEGIN_SRC emacs-lisp
;; CHANGE DIRED SORTING TO DIRECTORIES FIRST THEN FOLLOWED BY FILES
(setq dired-listing-switches "-alh --group-directories-first")
#+END_SRC 

#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "C-c C-q") 'wdired-change-to-wdired-mode)
#+END_SRC

#+SOURCE: https://oremacs.com/2015/07/27/counsel-recoll/
#+BEGIN_SRC emacs-lisp :tangle no
(defun ora-terminal ()
  "Switch to terminal. Launch if nonexistent."
  (interactive)
  (if (get-buffer "*ansi-term*")
      (switch-to-buffer "*ansi-term*")
    (ansi-term "/bin/bash"))
    (get-buffer-process "*ansi-term*"))

(defun ora-dired-open-term ()
  "Open an `ansi-term' that corresponds to current directory."
  (interactive)
  (let ((current-dir (dired-current-directory)))
    (term-send-string
     (ora-terminal)
     (if (file-remote-p current-dir)
         (let ((v (tramp-dissect-file-name current-dir t)))
           (format "ssh %s@%s\n"
                   (aref v 1) (aref v 2)))
       (format "cd '%s'\n" current-dir)))
    (setq default-directory current-dir)))

(define-key dired-mode-map (kbd "`") 'ora-dired-open-term)
#+END_SRC

** File Editing

A buffer is not a file. It is an intermediate form to hold contents before writing it to files. Being able to directly work on a file through its buffer is very convenient. I will call it a file-buffer.

*** Delete to Trash

Trash files to recycle bin, unlike shell:rm. Got the idea from Wilfred Hughes .emacs.d.

#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
#+END_SRC

*** Go To the Next/Previous File

Visit the next/previous files in the same directory directly from the file-buffer. Avoid the need to go through Dired or file searches. Got the code from [[https://emacs.stackexchange.com/a/12164][here]].

#+BEGIN_SRC emacs-lisp
;; GO TO THE NEXT/PREVIOUS FILE (BY NAME). USE PREFIX C-U TO GO BACK.
(defun jh/goto-next-file (&optional backward)
  "Find the next file (by name) in the current directory.
     With prefix arg, find the previous file."
  (interactive "P")
  (when buffer-file-name
    (let* ((file (expand-file-name buffer-file-name))
           (files (cl-remove-if (lambda (file) (cl-first (file-attributes file)))
                                (sort (directory-files (file-name-directory file) t nil t) 'string<)))
           (pos (mod (+ (cl-position file files :test 'equal) (if backward -1 1))
                     (length files))))
      (find-file (nth pos files)))))

(defun jh/goto-previous-file ()
  (interactive)
  (goto-next-file t))
#+END_SRC

*** Sudo Edit This File-Buffer

#+BEGIN_SRC emacs-lisp
;; USING TRAMP TO SUDO EDIT THE CURRENT FILE
;; SOURCE: https://stackoverflow.com/a/33280376
(defun jh/sudo-edit-this-file-buffer ()
  "Edit the current file with superuser privilege."
  (interactive)
  (find-file (concat "/sudo::" buffer-file-name)))
#+END_SRC

*** Rename This File-Buffer

Rename the visiting file from inside the buffer. Got the code from [fn:2].

#+BEGIN_SRC emacs-lisp
(defun jh/rename-this-file-buffer ()
  "Rename the current buffer and file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer is not visiting a file!")
      (let ((new-name (read-file-name "New name: " filename)))
        (cond
         ((vc-backend filename) (vc-rename-file filename new-name))
         (t
          (rename-file filename new-name t)
          (set-visited-file-name new-name t t)))))))
#+END_SRC

*** Delete This File-Buffer
   
Simply delete the visiting file from inside its buffer [fn:2].

#+BEGIN_SRC emacs-lisp
;; Delete the current file from the visiting buffer
(defun jh/delete-this-file-buffer ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (unless (buffer-file-name)
    (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-buffer)))
#+END_SRC

*** Run Command on This File-Buffer

Run an arbitrary on the file immediately through its buffer. E.g. =python <file>=.

** Reading PDF

Open pdf files in using =pdf-tools=. It can do more than reading PDFs in Emacs, but also includes a comfortable way to annotate and highlight texts. Alternative: llpp, zathura.

Dependencies [fn:6]:
#+BEGIN_SRC sh :dir /sudo::
apt install imagemagick libpng-dev zlib1g-dev libpoppler-glib-dev libpoppler-private-dev
#+END_SRC

To complete installation process, activate the package.
#+BEGIN_SRC emacs-lisp
(require-package 'pdf-tools)
(pdf-tools-install)
#+END_SRC

=pdf-tools= performance tweaks [fn:16].
#+BEGIN_SRC emacs-lisp
(setq pdf-cache-image-limit 15)
;; (setq pdf-cache-prefetch-delay X)
(setq image-cache-eviction-delay 15)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . pdf-view-mode))
#+END_SRC

Remap key in pdf-view-mode more vim-like.
#+BEGIN_SRC emacs-lisp
;; RE-MAP KEYS IN PDF-VIEW MODE FOR MORE INTUITIVE CONTROL
;; Souce: https://stackoverflow.com/a/14230685
;;        https://www.whitman.edu/mathematics/emacs_doc/emacs_447.html
(add-hook 'pdf-view-mode-hook
	  (lambda ()
	    (define-key pdf-view-mode-map (kbd "j") #'pdf-view-next-line-or-next-page)
	    (define-key pdf-view-mode-map (kbd "k") #'pdf-view-previous-line-or-previous-page)
	    (define-key pdf-view-mode-map (kbd "h") #'image-backward-hscroll)
	    (define-key pdf-view-mode-map (kbd "l") #'image-forward-hscroll)
	    (define-key pdf-view-mode-map (kbd "C-f") #'pdf-view-scroll-up-or-next-page)
	    (define-key pdf-view-mode-map (kbd "C-b") #'pdf-view-scroll-down-or-previous-page)
	    (define-key pdf-view-mode-map [remap quit-window] #'kill-this-buffer)))
#+END_SRC

To rotate a page 90 degree, use =pdftk= and apply the function [fn:8].
#+BEGIN_SRC sh :dir /sudo::
snap install pdftk
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun pdf-view--rotate (&optional counterclockwise-p page-p)
  "Rotate PDF 90 degrees.  Requires pdftk to work.\n
Clockwise rotation is the default; set COUNTERCLOCKWISE-P to
non-nil for the other direction.  Rotate the whole document by
default; set PAGE-P to non-nil to rotate only the current page.
\nWARNING: overwrites the original file, so be careful!"
  ;; error out when pdftk is not installed
  (if (null (executable-find "pdftk"))
      (error "Rotation requires pdftk")
    ;; only rotate in pdf-view-mode
    (when (eq major-mode 'pdf-view-mode)
      (let* ((rotate (if counterclockwise-p "left" "right"))
             (file   (format "\"%s\"" (pdf-view-buffer-file-name)))
             (page   (pdf-view-current-page))
             (pages  (cond ((not page-p)                        ; whole doc?
                            (format "1-end%s" rotate))
                           ((= page 1)                          ; first page?
                            (format "%d%s %d-end"
                                    page rotate (1+ page)))
                           ((= page (pdf-info-number-of-pages)) ; last page?
                            (format "1-%d %d%s"
                                    (1- page) page rotate))
                           (t                                   ; interior page?
                            (format "1-%d %d%s %d-end"
                                    (1- page) page rotate (1+ page))))))
        ;; empty string if it worked
        (if (string= "" (shell-command-to-string
                         (format (concat "pdftk %s cat %s "
                                         "output %s.NEW "
                                         "&& mv %s.NEW %s")
                                 file pages file file file)))
            (pdf-view-revert-buffer nil t)
          (error "Rotation error!"))))))

(defun pdf-view-rotate-clockwise (&optional arg)
  "Rotate PDF page 90 degrees clockwise.  With prefix ARG, rotate
entire document."
  (interactive "P")
  (pdf-view--rotate nil (not arg)))

(defun pdf-view-rotate-counterclockwise (&optional arg)
  "Rotate PDF page 90 degrees counterclockwise.  With prefix ARG,
rotate entire document."
  (interactive "P")
  (pdf-view--rotate :counterclockwise (not arg)))
#+END_SRC

** Reading Info Manual

#+BEGIN_SRC emacs-lisp
(require 'info)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.info\\'" . Info-on-current-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; ADD AN INFO DIRECTORY TO LOAD ADDITIONAL .INFO FILES
(add-to-list 'Info-directory-list "~/Info_Files_Manual")
#+END_SRC

* Elfeed -- RSS Reader

#+BEGIN_SRC emacs-lisp
(require-package 'elfeed)
#+END_SRC

Open elfeed in fullframe.
#+BEGIN_SRC emacs-lisp
(fullframe elfeed elfeed-search-quit-window)
#+END_SRC

Override default search filter to including the =focus= tag.
#+BEGIN_SRC emacs-lisp
(setq-default elfeed-search-filter "@1-week-ago +unread +focus")
#+END_SRC

Sort from oldest to newest because I am not using RSS to catch the "latest" news. And I am expecting myself to go through all the feeds.
#+BEGIN_SRC emacs-lisp
(setq elfeed-sort-order 'ascending)
#+END_SRC

Override default database directory at home folder.
#+BEGIN_SRC emacs-lisp
(setq elfeed-db-directory (expand-file-name "elfeed" user-emacs-directory))
#+END_SRC

Start =elfeed= in =evil-emacs-mode=.
#+BEGIN_SRC emacs-lisp
(add-to-list 'evil-emacs-state-modes 'elfeed-search-mode)
(add-to-list 'evil-emacs-state-modes 'elfeed-show-mode)
#+END_SRC

[Disable] Play video directly from the URL of a feed [fn:12]. (With a little modification to play "unlimited" resolution by default.
#+BEGIN_SRC emacs-lisp :tangle no
(defun elfeed-play-with-mpv ()
  "Play entry link with mpv."
  (interactive)
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
        (quality-arg "")
	(quality-val (completing-read "Max height resolution (0 for unlimited):" '("0" "480" "720") nil nil)))
    (setq quality-val (string-to-number quality-val))
    (message "Opening %s with height≤%s with mpv..." (elfeed-entry-link entry) quality-val)
    (when (< 0 quality-val)
      (setq quality-arg (format "--ytdl-format=[height<=?%s]" quality-val)))
    (start-process "elfeed-mpv" nil "mpv" quality-arg (elfeed-entry-link entry))))

(defun elfeed-open-with-eww ()
  "Open in eww with `eww-readable'."
  (interactive)
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single))))
    (eww  (elfeed-entry-link entry))
    (add-hook 'eww-after-render-hook 'eww-readable nil t)))

(defvar elfeed-visit-patterns
  '(("//[^/]*youtu\\.?be" . elfeed-play-with-mpv)
    ("phoronix" . elfeed-open-with-eww))
  "List of (regexps . function) to match against elfeed entry link to know
whether how to visit the link.")

(defun elfeed-visit-maybe-externally ()
  "Visit with external function if entry link matches `elfeed-visit-patterns',
show normally otherwise."
  (interactive)
  (let ((entry (if (eq major-mode 'elfeed-show-mode)
                   elfeed-show-entry
                 (elfeed-search-selected :single)))
        (patterns elfeed-visit-patterns))
    (while (and patterns (not (string-match (caar patterns) (elfeed-entry-link entry))))
      (setq patterns (cdr patterns)))
    (cond
     (patterns
      (elfeed-untag entry 'unread)
      (elfeed-search-update-entry entry)
      (funcall (cdar patterns)))
     ((eq major-mode 'elfeed-search-mode)
      (call-interactively 'elfeed-search-show-entry))
     (t (elfeed-show-visit)))))

(define-key elfeed-show-mode-map [remap shr-browse-url] #'elfeed-visit-maybe-externally)
#+END_SRC

#+NAME: Elfeed_Dependency
#+BEGIN_SRC sh :dir /sudo::
apt install mpv youtube-dl curl
#+END_SRC

Use curl to fetch feed. This will be faster.
#+BEGIN_SRC emacs-lisp
(setq elfeed-use-curl t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Source: https://emacs.stackexchange.com/a/2441
(defun jh/elfeed-mark-all-as-read()
  "Mark all messages as read."
  (interactive)
  (mark-whole-buffer)
  (elfeed-search-untag-all-unread))
#+END_SRC

Use elfeed-org to load feeds from an org file.
#+BEGIN_SRC emacs-lisp
(require-package 'elfeed-org)
#+END_SRC

Initialise elfeed-org to read the configuration file.
#+BEGIN_SRC emacs-lisp
(elfeed-org)
#+END_SRC

Define the org file used to store all the RSS links.
#+BEGIN_SRC emacs-lisp
(setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))
#+END_SRC

* Pocket Reader

Read pocket from Emacs [fn:28].
#+BEGIN_SRC emacs-lisp
(require-package 'pocket-reader)
(fullframe pocket-reader quit-window)
(evil-set-initial-state 'pocket-reader-mode 'emacs)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key pocket-reader-mode-map [remap pocket-reader-open-url] #'pocket-reader-open-in-external-browser)
(defalias 'pocket-reader-toggle-read-unread 'pocket-reader-toggle-archived)
(define-key pocket-reader-mode-map (kbd "r") #'pocket-reader-toggle-read-unread)
(define-key pocket-reader-mode-map (kbd "g") #'pocket-reader-refresh)
#+END_SRC

The only functionalities that I care:
1. Mark as read/unread.
2. Search.
3. Open in external browser.

A more intuitive function to simply ask user for URL input and then add it to Pocket.
#+BEGIN_SRC emacs-lisp
(defun jh/pocket-reader-add-link ()
  "Add URL from user input to Pocket."
  (interactive)
  (let ((url (read-string "URL: ")))
    (when (pocket-lib-add-urls url)
      (message "Added: %s" url))))
#+END_SRC

* ERC -- IRC Client

#+BEGIN_SRC emacs-lisp
(require 'erc)
(diminish 'erc-mode " ε")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq erc-server-coding-system '(utf-8 . utf-8))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq erc-autojoin-channels-alist '(("freenode.net" "#python" "#erc" "#emacs" "#org-mode" "##rust" "#startups" "#android-dev" "#linux" "#scheme" "#lisp" "#guile" "#vim")))
#+END_SRC

Hide the JOIN, PART, QUIT messages that clutter my chats.
#+BEGIN_SRC emacs-lisp
(setq erc-hide-list '("JOIN" "PART" "QUIT"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq erc-kill-buffer-on-part t)
(setq erc-kill-queries-on-quit t)
(setq erc-kill-server-buffer-on-quit t)
#+END_SRC

Align nickname?
#+BEGIN_SRC emacs-lisp
(require 'erc-fill)
(setq erc-fill-function 'erc-fill-static)
(setq erc-fill-static-center 19)
#+END_SRC

Enable logging in ERC.
#+BEGIN_SRC emacs-lisp
;; Logging
;; Useful for reading back the previous records.
(require 'erc-log)
(add-to-list 'erc-modules 'log)
(erc-update-modules)

(setq erc-log-channels-directory "~/.irc/logs")

(if (not (file-exists-p erc-log-channels-directory))
    (mkdir erc-log-channels-directory t))

(setq erc-save-buffer-on-part t)
;; (defadvice save-buffers-kill-emacs (before save-logs (arg) activate)
;;   (save-some-buffers t (lambda () (when (eq major-mode 'erc-mode) t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require-package 'erc-hl-nicks)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require-package 'erc-image)
(add-to-list 'erc-modules 'image)
(erc-update-modules)
#+END_SRC

References:
1. http://wiki.xkcd.com/irc/Hide_join_part_messages
2. https://github.com/bbatsov/emacs-dev-kit/blob/master/erc-config.el
   A good config for ERC.
3. https://www.reddit.com/r/emacs/comments/8ml6na/tip_how_to_make_erc_fun_to_use/
   For future reference.
4. http://emacslife.com/transcripts/2014-04-07%20Emacs%20NYC%20-%20IRC%20with%20ERC%20-%20Eric%20Collins.html

* Help Mode

#+BEGIN_SRC emacs-lisp
(require 'help)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (evil-set-initial-state 'help-mode 'emacs))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key help-mode-map (kbd "f") #'scroll-up-command)
(define-key help-mode-map (kbd "b") #'scroll-down-command)
#+END_SRC

* Man Mode

#+BEGIN_SRC emacs-lisp
(require 'man)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (evil-set-initial-state 'Man-mode 'emacs))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key Man-mode-map (kbd "f") #'scroll-up-command)
(define-key Man-mode-map (kbd "b") #'scroll-down-command)
#+END_SRC

* Dash Docsets in Emacs

I want to browse dash docsets in Emacs. Now, I am using =counsel-dash=. Check out the homepage [[https://github.com/dash-docs-el/counsel-dash][here]].
#+BEGIN_SRC emacs-lisp
(require-package 'counsel-dash)

(setq dash-docs-docsets-path "/home/zacque/.emacs.d/docsets") ;; use absolute path
(setq dash-docs-common-docsets '("OpenCV" "Keras" "Python 3" "Java" "NumPy" "Ansible" "PyTorch" "Terraform" "Matplotlib"))
#+END_SRC

Change the default doc browser to using eww.
#+BEGIN_SRC emacs-lisp
(setq dash-docs-browser-func 'eww)
#+END_SRC

Note:
1. counsel-dash-docsets-path should use absolute path only.
2. sqlite3 binaries should be found from my $PATH.

* Ansi-term, Term, Eshell, VTerm

** Ansi-Term

#+BEGIN_SRC emacs-lisp
(require 'term)
#+END_SRC

Remove the prompt.
#+BEGIN_SRC emacs-lisp
(setq explicit-shell-file-name "/bin/bash") ;; use bash by default
#+END_SRC

Kill the buffer after exiting the term.
#+BEGIN_SRC emacs-lisp
;; Source: https://oremacs.com/2015/01/01/three-ansi-term-tips/
(defun oleh-term-exec-hook ()
  (let* ((buff (current-buffer))
         (proc (get-buffer-process buff)))
    (set-process-sentinel
     proc
     `(lambda (process event)
        (if (string= event "finished\n")
            (kill-buffer ,buff))))))

(add-hook 'term-exec-hook 'oleh-term-exec-hook)
#+END_SRC

I couldn't remember which key is for which line/char-mode in term. Simply turn it into a toggle. Source: https://joelmccracken.github.io/entries/switching-between-term-mode-and-line-mode-in-emacs-term/
#+BEGIN_SRC emacs-lisp
(defun jnm/term-toggle-mode ()
  "Toggles term between line mode and char mode"
  (interactive)
  (if (term-in-line-mode)
      (term-char-mode)
    (term-line-mode)))

(define-key term-mode-map (kbd "C-c C-j") 'jnm/term-toggle-mode)
(define-key term-mode-map (kbd "C-c C-k") 'jnm/term-toggle-mode)

(define-key term-raw-map (kbd "C-c C-j") 'jnm/term-toggle-mode)
(define-key term-raw-map (kbd "C-c C-k") 'jnm/term-toggle-mode)
#+END_SRC

My ansi-term is black and white. This should make it more colourful.
#+BEGIN_SRC emacs-lisp
(require-package 'eterm-256color)
(add-hook 'term-mode-hook #'eterm-256color-mode)
#+END_SRC

This avoids some inputs from going to a newline before reaching the end.
#+BEGIN_SRC emacs-lisp
;; SOURCE: https://emacs.stackexchange.com/a/37831
(setq term-suppress-hard-newline t)
#+END_SRC

** Eshell as my Terminal

#+BEGIN_SRC emacs-lisp
(setq eshell-history-size 5000)
(setq eshell-save-history-on-exit t)
#+END_SRC

[Not Working] Caching sudo password in eshell. This is useful so that eshell does not prompt for password for every sudo command [fn:15].
#+BEGIN_SRC emacs-lisp :tangle no
(setq eshell-prefer-lisp-functions t)
(setq eshell-prefer-lisp-variables t)
(setq password-cache t)
(setq password-cache-expiry 600)
#+END_SRC

Open a new =shell= from the current buffer-directory. [fn:4]
#+BEGIN_SRC emacs-lisp
(defun jh/shell-here ()
  "Opens up a new shell in the directory associated with the current buffer's file."
  (interactive)
  (let* ((parent (if (buffer-file-name)
                     (file-name-directory (buffer-file-name))
                   default-directory))
         (name (car (last (split-string parent "/" t)))))
    (shell (concat "*shell: " name "*"))))
#+END_SRC

Progress bar for apt in shell. Source: https://oremacs.com/2019/03/24/shell-apt/
#+BEGIN_SRC emacs-lisp
(advice-add
 'ansi-color-apply-on-region
 :before 'ora-ansi-color-apply-on-region)

(defun ora-ansi-color-apply-on-region (begin end)
  "Fix progress bars for e.g. apt(8).
Display progress in the mode line instead."
  (let ((end-marker (copy-marker end))
        mb)
    (save-excursion
      (goto-char (copy-marker begin))
      (while (re-search-forward "\0337" end-marker t)
        (setq mb (match-beginning 0))
        (when (re-search-forward "\0338" end-marker t)
          (ora-apt-progress-message
           (substring-no-properties
            (delete-and-extract-region mb (point))
            2 -2)))))))

;; (defun ora-apt-progress-message (progress)
;;   (setq mode-line-process
;;         (if (string-match
;;              "Progress: \\[ *\\([0-9]+\\)%\\]" progress)
;;             (list
;;              (concat ":%s "
;;                      (match-string 1 progress)
;;                      "%%%% "))
;;           '(":%s")))
;;   (force-mode-line-update))

(defun ora-apt-progress-message (progress)
  (message
   (replace-regexp-in-string
    "%" "%%"
    (ansi-color-apply progress))))
#+END_SRC
*** Aweshell
https://github.com/manateelazycat/aweshell

Trying it out <2019-06-06 Thu>.
#+BEGIN_SRC emacs-lisp
(require 'aweshell)
#+END_SRC

** Libvterm/VTerm

*** Pre-requisite
<2019-08-25 Sun>

1. Libterm
   #+BEGIN_SRC shell
   sudo apt-get install libvterm-dev
   #+END_SRC
   
2. Libtool-bin
   #+BEGIN_SRC shell
   sudo apt-get install libtool-bin
   #+END_SRC

Fullfill the prerequisite. Clone the git repo. Build. And done.

*** Config

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/gitrepo/software/emacs-libvterm")
(require 'vterm)
#+END_SRC

To make the line wrapping in VTerm works normally. Reference: https://superuser.com/a/988843
#+BEGIN_SRC emacs-lisp
(add-hook 'vterm-mode-hook
	  (lambda () (setq truncate-lines t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'vterm-mode 'emacs)
#+END_SRC

Exit buffer after exit vterm. Reference: https://github.com/akermu/emacs-libvterm/issues/24#issuecomment-438048042
#+BEGIN_SRC emacs-lisp
(add-hook 'vterm-exit-functions (lambda (process)
				  (kill-buffer)))
#+END_SRC

* A Mode for Reading

Use writeroom-mode. The package is written for a distraction free writing experience. It turns out that it is also good for reading.
#+BEGIN_SRC emacs-lisp
(require-package 'writeroom-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq writeroom-width 0.6)
#+END_SRC

* Try: Try Out Emacs Packages

Works for packages on =package-archives= and also any elisp file from the Web.
#+BEGIN_SRC emacs-lisp
(require-package 'try)
#+END_SRC

References:
1. https://github.com/larstvei/try

* Miscellaneous

** Check Hanging Parenthesis

The main problem I have using literate programming mode is the hanging parenthesis.

#+BEGIN_SRC emacs-lisp
(defun xah-check-parens-balance ()
  "Check if there are unbalanced parentheses/brackets/quotes in current bufffer or selection.
If so, place cursor there, print error to message buffer.

URL `http://ergoemacs.org/emacs/emacs_check_parens_balance.html'
Version 2018-07-03"
  (interactive)
  (let* (
         ($bracket-alist
          '( (?“ . ?”) (?‹ . ?›) (?« . ?») (?【 . ?】) (?〖 . ?〗) (?〈 . ?〉) (?《 . ?》) (?「 . ?」) (?『 . ?』) (?{ . ?}) (?\[ . ?\]) (?\( . ?\))))
         ;; regex string of all pairs to search.
         ($bregex
          (let (($tempList nil))
            (mapc
             (lambda (x)
               (push (char-to-string (car x)) $tempList)
               (push (char-to-string (cdr x)) $tempList))
             $bracket-alist)
            (regexp-opt $tempList )))
         $p1
         $p2
         ;; each entry is a vector [char position]
         ($stack '())
         ($char nil)
         $pos
         $is-closing-char-p
         $matched-open-char
         )
    (if (region-active-p)
        (setq $p1 (region-beginning) $p2 (region-end))
      (setq $p1 (point-min) $p2 (point-max)))

    (save-excursion
      (save-restriction
        (narrow-to-region $p1 $p2)
        (progn
          (goto-char 1)
          (while (re-search-forward $bregex nil "move")
            (setq $pos (point))
            (setq $char (char-before))
            (progn
              (setq $is-closing-char-p (rassoc $char $bracket-alist))
              (if $is-closing-char-p
                  (progn
                    (setq $matched-open-char
                          (if $is-closing-char-p
                              (car $is-closing-char-p)
                            (error "logic error 64823. The char %s has no matching pair."
                                   (char-to-string $char))))
                    (if $stack
                        (if (eq (aref (car $stack) 0) $matched-open-char )
                            (pop $stack)
                          (push (vector $char $pos) $stack ))
                      (progn
                        (goto-char $pos)
                        (error "First mismtach found. the char %s has no matching pair."
                               (char-to-string $char)))))
                (push (vector $char $pos) $stack ))))
          (if $stack
              (progn
                (goto-char (aref (car $stack) 1))
                (message "Mismtach found. The char %s has no matching pair." $stack))
            (print "All brackets/quotes match.")))))))
#+END_SRC

** Handy Small Functions

Open the current file-buffer using system viewer [fn:32].
#+BEGIN_SRC emacs-lisp
(defun jh/open-buffer-in-system-viewer()
  "Open current file-buffer using default desktop viewer."
  (interactive)
  (let ((path (if (buffer-file-name) (buffer-file-name) default-directory)))
    (let ((process-connection-type nil)
	  (cmd "/usr/bin/xdg-open"))
      (start-process "" nil cmd path))))
#+END_SRC

Open terminal in current file directory [fn:32].
#+BEGIN_SRC emacs-lisp
(defun jh/open-dir-in-terminal-here()
  "Open a new terminal window in the current dir."
  (interactive)
  (let ((process-connection-type nil))
    (start-process "" nil "x-terminal-emulator" (concat "--working-directory=" default-directory))))
#+END_SRC
Note: default-directory is a buffer-local variable that changes with buffers.

#+BEGIN_SRC emacs-lisp
(defun jh/search-sync-files()
  "Search from all files listed recursively in the sync dir."
  (interactive)
  (counsel-file-jump nil jh/sync-directory)) ;; using counsel-file-jump instead of find file
#+END_SRC

Add a dispatch option to =counsel-file-jump= to jump to the directory.
#+BEGIN_SRC emacs-lisp
(ivy-set-actions 'counsel-file-jump '(("d" open-file-directory-from-path "directory")))
#+END_SRC

Directly search the contents of files in sync directory.
#+BEGIN_SRC emacs-lisp
(defun jh/search-sync-contents()
  "Search for sync contents."
  (interactive)
  (counsel-rg nil jh/sync-directory nil))
#+END_SRC

** KeyFreq

#+BEGIN_SRC emacs-lisp
(require 'keyfreq)
(keyfreq-mode 1)
(keyfreq-autosave-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq keyfreq-file (jh/emacs-subdirectory "emacs.keyfreq"))
#+END_SRC

** Counsel-firefox-bookmarks

A handy tool for me to search firefox bookmarks from within Emacs.

Right now, I am git cloning the package into the .emacs.d/lisp directory. It might be merged into the =ivy= package in the future.

#+BEGIN_SRC emacs-lisp
(require 'counsel-firefox-bookmarks)
(setq counsel-firefox-bookmarks-file "/home/zacque/sync/firefox-bookmarks-autobackup.html")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(defun incognito-tab (x)
  "Browse candidate in Firefox private window."
  (browse-url (cadr x)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(ivy-set-actions 'counsel-firefox-bookmarks '(("i" incognito-tab "incognito-tab")))
#+END_SRC

References:
1. https://github.com/tangxinfa/counsel-firefox-bookmarks
2. https://www.emacswiki.org/emacs/BrowseUrl#toc29
   With private-browsing.

** Printing

#+BEGIN_SRC emacs-lisp
(setq ps-line-number t) ; print with line numbers
#+END_SRC

Printer at my dorm can only print black-and-white colours.
#+BEGIN_SRC emacs-lisp
(setq ps-print-color-p 'black-white) ; always print black-and-white
#+END_SRC

** Emacs Multimedia System (EMMS)

#+BEGIN_SRC emacs-lisp
(require-package 'emms)
(emms-all)
(emms-default-players)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq emms-source-file-default-directory "~/Music/")
#+END_SRC

** Immortal Scratch

#+BEGIN_SRC emacs-lisp
(require-package 'immortal-scratch)
(add-hook 'after-init-hook 'immortal-scratch-mode)
#+END_SRC

* Enable Emacs Server

Allow the use of emacsclient from terminal.
#+BEGIN_SRC emacs-lisp
;; ALLOW ACCESS FROM EMACSCLIENT
(require 'server)
(unless (server-running-p)
  (server-start))
#+END_SRC

* Config File Ending
  
** Edit This File

Make it easy to find and edit this config file.
#+BEGIN_SRC emacs-lisp
(defun jh/find-config()
  "Edit config.org."
  (interactive)
  (find-file "~/.emacs.d/config.org"))
#+END_SRC

** Temp for counsel-input-alist

#+BEGIN_SRC emacs-lisp
(setq-default ivy-initial-inputs-alist '((man . "^")
                                         (woman . "^")))
#+END_SRC

** Provide =init-main= variable

#+BEGIN_SRC emacs-lisp
(provide 'init-main)
#+END_SRC

* Archived                    :noexport:
:PROPERTIES:
:header-args: :tangle no
:END:
** Rendering HTML File-Buffer in a Browser

Status: Archived
Reason: This function is replaced by a more general system viewer function.

Sometimes I would have to read HTML files. Not to read its code, but its code. So its handy to be able to read/browse the file from a browser or, at least, a HTML renderer.

#+BEGIN_SRC emacs-lisp :tangle no
;; Browse current HTML file
(defun browse-current-html-file-buffer ()
  "Open the current file as a URL using `browse-url'."
  (interactive)
  (let ((file-name (buffer-file-name)))
    (if (and (fboundp 'tramp-tramp-file-p)
             (tramp-tramp-file-p file-name))
        (error "Cannot open tramp file")
      (browse-url (concat "file://" file-name)))))
#+END_SRC

** mu4e -- Email Client

I use =mu4e= to read emails from Emacs. On the desktop, =isync= package needs to be installed.
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
(require 'mu4e)
#+END_SRC

Open in full frame.
#+BEGIN_SRC emacs-lisp
(fullframe mu4e mu4e-quit)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq mu4e-confirm-quit nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq mu4e-hide-index-messages t)
#+END_SRC

Use mu4e as the default Emacs program to send email for =C-x m (compose-mail)= or =report-emacs-bug=.
#+BEGIN_SRC emacs-lisp
(setq mail-user-agent 'mu4e-user-agent) ;; use a the default client on emacs
#+END_SRC

Overrides the default folders to store messages. Note: The folder can be defined dynamically at runtime and changes according to the attributes of an email.
#+BEGIN_SRC emacs-lisp
(setq mu4e-maildir	 "~/Mail/outlook") ;; top-level Maildir

(setq mu4e-sent-folder "/Sent" ;; sent messages
      mu4e-drafts-folder "/Drafts" ;; unfinished messages
      mu4e-trash-folder "/Deleted" ;; trashed messages
      mu4e-refile-folder "/Archives") ;; saved messages
#+END_SRC

Override default to show both sender name and address. This makes me easier to filter sender using search query.
#+BEGIN_SRC emacs-lisp
(setq mu4e-view-show-addresses t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'message-send-hook
  (lambda ()
    (unless (yes-or-no-p "Sure you want to send this?")
      (signal 'quit nil))))
#+END_SRC

Defines the shell command to retrieve mails. Updates mail and index periodically for every N seconds.
#+BEGIN_SRC emacs-lisp :tangle no
(setq mu4e-get-mail-command "mbsync -a"
      mu4e-update-interval (* 10 60)) ;; re-index every 10 minutes
#+END_SRC

Update using systemd in the background.
#+BEGIN_SRC emacs-lisp
(setq mu4e-index-update-in-background nil
      mu4e-update-interval nil)
#+END_SRC

Speeds up mu4e updates.
#+BEGIN_SRC emacs-lisp
(setq mu4e-index-cleanup nil  ;; don't do a full cleanup check
      mu4e-index-lazy-check t) ;; don't consider up-to-date dirs
#+END_SRC

Sending mail from mu4e.
#+BEGIN_SRC emacs-lisp
;; Tell message-mode how to send email
(setq message-send-mail-function 'smtpmail-send-it)

;; Define the mail server to send email
(setq smtpmail-smtp-server "smtp-mail.outlook.com"
      smtpmail-smtp-service 587
      smtpmail-stream-type 'starttls)

;; Kill buffer after sending, instead of burying the buffer away
(setq message-kill-buffer-on-exit t) 
#+END_SRC

Queuing email is useful for offline mode.
#+BEGIN_SRC emacs-lisp :tangle no
(setq smtpmail-queue-mail nil
      smtpmail-queue-dir "~/Mail/outlook/queue")
#+END_SRC

#+BEGIN_SRC shell
mkdir ~/Mail/outlook/queue
touch ~/Mail/outlook/queue/.noindex # informs mu not to index this dir
#+END_SRC

Enable viewing images inline.
#+BEGIN_SRC emacs-lisp
;; Enable inline images
(setq mu4e-view-show-images t)
;; use imagemagick support
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))
#+END_SRC

Display rich-text messages in HTML. Set =shr-color-visible-luminance-min= to 80 if I am using dark theme.
#+BEGIN_SRC emacs-lisp
(setq mu4e-view-prefer-html t)

(add-hook 'mu4e-view-mode-hook
	  (lambda()
	    ;; try to emulate some of the eww key-bindings
	    (local-set-key (kbd "<tab>") 'shr-next-link)
	    (local-set-key (kbd "<backtab>") 'shr-previous-link)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Use fancy non-ASCII char in various places
(setq mu4e-use-fancy-chars t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Works better for mbsync
(setq mu4e-change-filenames-when-moving t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq mu4e-completing-read-function 'ivy-completing-read)
#+END_SRC

Gets an audio notification when indexing process sees an update.
#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'mu4e-index-updated-hook
  (defun new-mail-sound ()
    (shell-command "mpv ~/Sounds/prayer_bell.mp3&")))
#+END_SRC

Speed up mu4e html rendering speed. It's very slow whenever I open an email.
Dependency: =w3m=.
#+BEGIN_SRC emacs-lisp
;; (setq mu4e-html2text-command "w3m -T text/html")

(setq w3m-default-display-inline-images t)

;; Source: https://etienne.depar.is/emacs.d/mu4e.html
(setq mu4e-html2text-command "w3m -dump -I utf8 -O utf8 -T text/html -cols 72 -o display_link_number=true -o auto_image=true -o display_image=true -o ignore_null_img_alt=true")
#+END_SRC

Open unreadable file in browser.
#+BEGIN_SRC emacs-lisp
(add-to-list 'mu4e-view-actions
  '("ViewInBrowser" . mu4e-action-view-in-browser) t)
#+END_SRC

*** Personal Settings

Maildirs that I use frequently; access them with 'j' ('jump').
#+BEGIN_SRC emacs-lisp
(setq mu4e-maildir-shortcuts
      '(("/Inbox" . ?i)
	("/Archives/2019" . ?a)
	("/Deleted" . ?d)
	("/Sent" . ?s)))
#+END_SRC

Defines mu4e search bookmarks.
#+BEGIN_SRC emacs-lisp
(setq mu4e-bookmarks
  `( ,(make-mu4e-bookmark
       :name  "Inbox unread messages"
       :query "maildir:/Inbox AND flag:unread"
       :key ?u)
     ,(make-mu4e-bookmark
       :name "Today's messages"
       :query "date:today..now"
       :key ?t)
     ,(make-mu4e-bookmark
       :name "Last 7 days"
       :query "date:7d..now"
       :key ?w)
     ,(make-mu4e-bookmark
       :name "Flagged in INBOX"
       :query "maildir:\"/INBOX\" and flag:flagged"
       :key ?f)
     ,(make-mu4e-bookmark
       :name  "Inbox messages with pdf attachment"
       :query "mime:application/pdf and maildir:/Inbox"
       :key ?a)))
#+END_SRC

Override the default directory for saving attachements.
#+BEGIN_SRC emacs-lisp
(setq mu4e-attachment-dir "~/Downloads")
#+END_SRC

** ob-ipython

[Archived] 
1. There is no instruction on start using it. How to start using it?
2. The package is out of maintenance. Replaced by package emacs-jupyter.
#+BEGIN_EXAMPLE
Traceback (most recent call last):
  File "/home/zacque/.emacs.d/elpa/ob-ipython-20180224.953/client.py", line 60, in <module>
    c = create_client(args.conn_file)
  File "/home/zacque/.emacs.d/elpa/ob-ipython-20180224.953/client.py", line 43, in create_client
    cf = find_connection_file('emacs-' + name)
  File "/home/zacque/.local/lib/python3.6/site-packages/jupyter_client/connect.py", line 218, in find_connection_file
    raise IOError("Could not find %r in %r" % (filename, path))
OSError: Could not find 'emacs-mtpltlib' in ['.', '/run/user/1000/jupyter']
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(require-package 'ob-ipython)
#+END_SRC

References:
1. http://kitchingroup.cheme.cmu.edu/blog/2017/01/29/ob-ipython-and-inline-figures-in-org-mode/
2. http://cachestocaches.com/2018/6/org-literate-programming/
3. https://github.com/gregsexton/ob-ipython

** Vim-like End-of-File Trailing Tildes

[Archived] I don't think I really find it to be useful.

Like VIM, make my Emacs files display tildes after EOF [fn:5].
#+BEGIN_SRC emacs-lisp
(setq-default indicate-empty-lines t)
(define-fringe-bitmap 'tilde [0 0 0 113 219 142 0 0] nil nil 'center)
(setcdr (assq 'empty-line fringe-indicator-alist) 'tilde)
(set-fringe-bitmap-face 'tilde 'font-lock-function-name-face)
#+END_SRC

** Org-Caldav

Note: Package oauth2 is needed for sync to Google cal.
#+BEGIN_SRC emacs-lisp
(require-package 'org-caldav)
(require-package 'oauth2)
#+END_SRC

Because Org-caldav uses iCalendar under the hood.
#+BEGIN_SRC emacs-lisp
(setq org-icalendar-timezone "+08")
(setq org-icalendar-alarm-time "30")
(setq org-icalendar-use-deadline '(event-if-not-todo todo-due))
(setq org-icalendar-use-scheduled '(todo-start))
(setq org-icalendar-include-sexps t)
(setq org-icalendar-include-todo 'all)
#+END_SRC

Org will evaluate code block on export. This will disable it to speed up export to iCalendar format.
#+SOURCE: https://emacs.stackexchange.com/a/50359
#+BEGIN_SRC emacs-lisp
(setq org-export-use-babel nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-export-select-tags '("export" "ical"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-icalendar-combined-agenda-file (jh/file-in-sync-directory "org" "org.ics"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-caldav-url 'google)
(setq org-caldav-oauth2-client-id "**REMOVED**")
(setq org-caldav-oauth2-client-secret "**REMOVED**")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-caldav-select-tags '("ical"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-caldav-sync-direction 'org->cal)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-caldav-calendars `((
                              :calendar-id ,(password-store-get-field "personal-info" "personal-gmail")
                              :files (,(jh/file-in-sync-directory "org" "personal.txt"))
                              :inbox ,(jh/file-in-sync-directory "org" "google_caldav.org"))))
#+END_SRC

* Footnotes

[fn:32] http://ergoemacs.org/emacs/emacs_shell_vs_term_vs_ansi-term_vs_eshell.html

[fn:31] https://writequit.org/denver-emacs/presentations/2017-04-11-time-clocking-with-org.html

[fn:30] http://doc.norang.ca/org-mode.html#Clocking

[fn:16] https://www.reddit.com/r/emacs/comments/8uu7hb/question_pdftools_use_alot_of_ram/e1ir7c0

[fn:28] https://github.com/alphapapa/pocket-reader.el

[fn:27] [[info:emacs#Fonts][info:emacs#Fonts]] 

[fn:26] https://emacs.stackexchange.com/a/38241

[fn:22] https://github.com/rust-lang/rls

[fn:21] https://github.com/palantir/python-language-server

[fn:20] https://github.com/flycheck/flycheck/pull/1412

[fn:19] https://emacs.stackexchange.com/questions/38841/counsel-m-x-always-shows

[fn:18] http://tumashu.github.io/pyim/

[fn:17] https://github.com/Silex/docker.el/pull/73 && https://github.com/Silex/docker.el/issues/76

[fn:15] https://emacs.stackexchange.com/questions/5608/how-to-let-eshell-remember-sudo-password-for-two-minutes

[fn:14] https://github.com/PythonNut/historian.el

[fn:13] https://github.com/purcell/emacs.d/blob/master/lisp/init-ivy.el

[fn:12] https://github.com/skeeto/elfeed/issues/267 OR https://gitlab.com/ambrevar/dotfiles/blob/master/.emacs.d/lisp/init-elfeed.el

[fn:11] https://robmoss.github.io/2018/02/19/Live-coding-Emacs-and-ghci

[fn:9] https://realpython.com/emacs-the-best-python-editor/

[fn:8] https://emacs.stackexchange.com/a/24766

[fn:7] http://www.nongnu.org/geiser/

[fn:6] https://github.com/politza/pdf-tools

[fn:5] https://www.reddit.com/r/emacs/comments/2kdztw/emacs_in_evil_mode_show_tildes_for_blank_lines/

[fn:4] https://www.reddit.com/r/emacs/comments/1zkj2d/advanced_usage_of_eshell/

[fn:3]  https://web.archive.org/web/20141020081338/http://truongtx.me:80/2013/04/25/dired-as-default-file-manager-5-customize-ls-command/

[fn:2] https://emacsredux.com/blog/2013/05/04/rename-file-and-buffer/

